<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="generator" content="Jekyll v3.8.5">

		<link href="https://fonts.googleapis.com/css?family=Roboto|Inconsolata:400,700" rel="stylesheet">
		<link rel="stylesheet" href="/css/modules/bootstrap.css">
		<link rel="stylesheet" href="/css/modules/font-awesome-4.7.0/css/font-awesome.min.css">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="stylesheet" href="/css/modules/swagger-ui.min.css">
		<link rel="stylesheet" href="/css/modules/viewer.min.css">
		<link rel="stylesheet" href="/css/overrides.css">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="manifest" href="/images/manifest.json">
		<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
		<link rel="shortcut icon" href="/images/favicon.ico">
		<meta name="msapplication-config" content="/images/browserconfig.xml">
		<meta name="theme-color" content="#ffffff">

		<script src="/js/modules/jquery-2.2.0.min.js"></script>
		<script src="/js/modules/bootstrap.min.js"></script>
		<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>
		<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-resource.min.js"></script>
		<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-route.min.js"></script>
		<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-animate.min.js"></script>
		<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-sanitize.min.js"></script>
		<script src="/js/modules/viewer.min.js"></script>
		<script src="/js/modules/swagger-ui/angular-swagger-ui.min.js"></script>
		<script src="/js/modules/swagger-ui/swagger-external-references.min.js"></script>
		<script src="/js/modules/swagger-ui/swagger1-to-swagger2-converter.min.js"></script>
		<script src="/js/swagger-authentication.js"></script>
		<script src="/js/app.js"></script>

		<title> Search |  OpenPaaS documentation</title>
		<link type="application/atom+xml" rel="alternate" href="https://openpaas.github.io/openpaas-doc/feed.xml" title="OpenPaaS Documentation" />

		
	</head>

	<body>
		<header>
			<h1>
				<a href="/"><img src="/images/white-logo.png" width="40" height="40" alt="OpenPaaS Documentation logo"></a>
				OpenPaaS Documentation
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">Welcome</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/getting-started/docker/">Getting started</a>
							<ul>
								
									<li class="nav-item "><a href="/getting-started/docker/">Get started with Docker</a></li>
								
									<li class="nav-item "><a href="/getting-started/linux/">Get started with Linux (deprecated)</a></li>
								
									<li class="nav-item "><a href="/getting-started/supported-platforms/">Supported platforms</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/apis/web/">APIs</a>
							<ul>
								
									<li class="nav-item "><a href="/apis/web/">Web API</a></li>
								
									<li class="nav-item "><a href="/apis/swagger/">Swagger</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/apis/auth/index/">APIs - Auth</a>
							<ul>
								
									<li class="nav-item "><a href="/apis/auth/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/apis/auth/basic/">Basic Access</a></li>
								
									<li class="nav-item "><a href="/apis/auth/cookies/">Cookies</a></li>
								
									<li class="nav-item "><a href="/apis/auth/lemonldap/">SSO - LemonLDAP</a></li>
								
									<li class="nav-item "><a href="/apis/auth/oidc/">OpenID Connect</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/dev/debug/">Dev</a>
							<ul>
								
									<li class="nav-item "><a href="/dev/debug/">Debug</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/devops/james/">Devops</a>
							<ul>
								
									<li class="nav-item "><a href="/devops/james/">James</a></li>
								
									<li class="nav-item "><a href="/devops/kibana/">Kibana</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/frontend/vue/">Frontend</a>
							<ul>
								
									<li class="nav-item "><a href="/frontend/vue/">Vue.js</a></li>
								
									<li class="nav-item "><a href="/frontend/vue-auth/">Vue Authentication</a></li>
								
									<li class="nav-item "><a href="/frontend/vue-components/">Vue Components</a></li>
								
									<li class="nav-item "><a href="/frontend/i18n/">I18n</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/core/configuration/">OpenPaaS Core</a>
							<ul>
								
									<li class="nav-item "><a href="/core/configuration/">Configuration</a></li>
								
									<li class="nav-item "><a href="/core/pubsub/">Pubsub</a></li>
								
									<li class="nav-item "><a href="/core/eventsourcing/">EventSourcing</a></li>
								
									<li class="nav-item "><a href="/core/provisioning/">Provisioning</a></li>
								
									<li class="nav-item "><a href="/core/search/">Search</a></li>
								
									<li class="nav-item "><a href="/core/i18n/">I18n</a></li>
								
									<li class="nav-item "><a href="/core/people/">People API</a></li>
								
									<li class="nav-item "><a href="/core/health-check/">Health Check</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/howto/index/">OpenPaaS Modules</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/howto/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/modules/howto/quickstart/">Quickstart</a></li>
								
									<li class="nav-item "><a href="/modules/howto/deep-dive/">Deep dive</a></li>
								
									<li class="nav-item "><a href="/modules/howto/install/">Install</a></li>
								
									<li class="nav-item "><a href="/modules/howto/electron-compatibility/">How to be Electron compatible</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/admin/index/">OpenPaaS Modules - Admin</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/admin/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/modules/admin/domains/">Domains</a></li>
								
									<li class="nav-item "><a href="/modules/admin/configuration-page/">Add a configuration page</a></li>
								
									<li class="nav-item "><a href="/modules/admin/rest-api/">REST API</a></li>
								
									<li class="nav-item "><a href="/modules/admin/elasticsearch/">Elasticsearch</a></li>
								
									<li class="nav-item "><a href="/modules/admin/technical-users/">Technical users</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/calendar/index/">OpenPaaS Modules - Calendar</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/calendar/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/modules/calendar/shared/">Shared Calendars</a></li>
								
									<li class="nav-item "><a href="/modules/calendar/resource/">Calendar Resources</a></li>
								
									<li class="nav-item "><a href="/modules/calendar/api/">REST API</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/community/index/">OpenPaaS Modules - Community</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/community/index/">Overview</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/contact/index/">OpenPaaS Modules - Contact</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/contact/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/modules/contact/collected/">Collected contacts</a></li>
								
									<li class="nav-item "><a href="/modules/contact/shared/">Shared Address Books</a></li>
								
									<li class="nav-item "><a href="/modules/contact/domain-address-book/">Domain address book</a></li>
								
									<li class="nav-item "><a href="/modules/contact/domain-members-address-book/">Domain members address book</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/group/index/">OpenPaaS Modules - Group</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/group/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/modules/group/rest-api/">REST API</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/james/index/">OpenPaaS Modules - James</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/james/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/modules/james/rest-api/">REST API</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/jobqueue/index/">OpenPaaS Modules - Job Queue</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/jobqueue/index/">Overview</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/smartsla/index/">OpenPaaS Modules - SmartSLA</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/smartsla/index/">Overview</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/unifiedinbox/index/">OpenPaaS Modules - Unified Inbox</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/unifiedinbox/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/modules/unifiedinbox/identity/">Identity</a></li>
								
									<li class="nav-item "><a href="/modules/unifiedinbox/rest-api/">REST API</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/modules/videoconference/index/">OpenPaaS Modules - VideoConference</a>
							<ul>
								
									<li class="nav-item "><a href="/modules/videoconference/index/">Overview</a></li>
								
									<li class="nav-item "><a href="/modules/videoconference/screensharing/">Screensharing</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/testing/midway-backend-test/index/">OpenPaaS Test Automation</a>
							<ul>
								
									<li class="nav-item "><a href="/testing/midway-backend-test/index/">Midway Backend Test</a></li>
								
							</ul>
						</li>
					
				</ul>

				<ul>
					<li class="nav-item top-level">
						<a href="javascript:;">Keep In Touch</a>
						<ul>
							<li class="nav-item">
								<a href="https://twitter.com/AwesomePaaS">@AwesomePaaS on Twitter</a>
							</li>
							<li class="nav-item">
								<a href="https://www.facebook.com/AwesomePaaS/">AwesomePaaS on Facebook</a>
							</li>
							<li class="nav-item">
								<a href="https://github.com/linagora/openpaas-esn/">Github</a>
							</li>
							<li class="nav-item">
								<a href="https://forum.open-paas.org/">Forum</a>
							</li>
							<li class="nav-item">
								<a href="https://open-paas.org/">Web Site</a>
							</li>
							<li class="nav-item">
								<a href="https://linagora.com/">Linagora</a>
							</li>
						</ul>
					</li>
				</ul>


			</nav>
		</header>
		<section class="main">
			<div class="page-header">
				<h2>OpenPaaS Documentation</h2>
				<div class="page-title">
					<h3>Search</h3>
					<a href="https://github.com/linagora/openpaas-doc/edit/master/search.html" title="Edit this page on Github">
						<i class="fa fa-pencil-square-o" aria-hidden="true"></i>
					</a>
				</div>
			</div>
			<article class="content">
				<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					

					"apis-auth-basic": {
						"id": "apis-auth-basic",
						"title": "Basic Access",
						"category": "",
						"url": " /apis/auth/basic/",
						"content": "Basic Access Authentication is a method for a HTTP client to provide username and password when making a HTTP request to the server as described in the RFC2617. curl sample We assume that the a user is registered in OpenPaaS with username admin@open-paas.org and password secret. To illustrate the API response, we are calling the api user endpoint which returns the current authenticated user. Request curl --user admin@open-paas.org:secret http: localhost:8080 api user Response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 { \"_id\":\"592294b7666cdc5db24b3e31\", \"firstname\":\"admin\", \"lastname\":\"admin\", \"preferredEmail\":\"admin@open-paas.org\", \"emails\":[ \"admin@open-paas.org\" ], \"domains\":[ { \"domain_id\":\"592294b7666cdc5db24b3e32\", \"joined_at\":\"2017-05-22T07:35:20.228Z\" } ], \"avatars\":[ ], \"accounts\":[ { \"type\":\"email\", \"timestamps\":{ \"creation\":\"2017-05-22T07:35:19.562Z\" }, \"preferredEmailIndex\":0, \"emails\":[ \"admin@open-paas.org\" ], \"hosted\":false } ], \"followers\":0, \"followings\":0, \"isPlatformAdmin\":false, \"disabled\":false, \"configurations\":{ \"modules\":[ { \"name\":\"core\", \"configurations\":[ { \"name\":\"application-menu.profile\", \"value\":true }, { \"name\":\"homePage\", \"value\":\"calendar.main\" }, { \"name\":\"businessHours\", \"value\":[ { \"daysOfWeek\":[ 1, 2, 3, 4, 5 ], \"start\":\"09:00\", \"end\":\"18:00\" } ] }, { \"name\":\"datetime\", \"value\":{ \"use24hourFormat\":false } } ] }, { \"name\":\"linagora.esn.unifiedinbox\", \"configurations\":[ ] } ] } }"
					}

					
				
			
		
			
				
					,
					

					"apis-auth-cookies": {
						"id": "apis-auth-cookies",
						"title": "Cookies",
						"category": "",
						"url": " /apis/auth/cookies/",
						"content": "How to authenticate a given user to the OpenPaaS platform? From his credentials, you’ll authenticate a user and then get this user’s object containing domains ids to which he belongs to. Let’s see details: Log your user into the application by issuing a POST request to login URL. The response will contain a cookie which you will be able to use in next requests as long as the session is open. Parameters: Name: credentials (body) The credentials for authentication. For example: 1 2 3 4 5 6 7 8 9 { \"username\": \"string\", \"password\": \"string\", \"rememberme\": true, \"recaptcha\": { \"data\": {}, \"needed\": true } } Responses: Code: 200 We will have as response the user object which contains the user’s domain ids. Code: 400 Bad request. Invalid request body or parameters. Code: 403 Forbidden. The user does not have enough rights. Code: 500 Internal server error - Something went bad on the server side."
					}

					
				
			
		
			
				
					,
					

					"apis-auth-index": {
						"id": "apis-auth-index",
						"title": "Overview",
						"category": "",
						"url": " /apis/auth/index/",
						"content": "There are several ways to authenticate authorize users in OpenPaaS: Basic Access Authentication. Cookies. OAuth. Even if OAuth is not an authentication protocol, this section shows how to use OAuth in OpenPaaS. Single sign-on (SSO). SSO is a property of access control of multiple related, yet independent, software systems. With this property, a user logs in with a single ID and password to gain access to a connected system or systems without using different usernames or passwords, or in some configurations seamlessly sign on at each system. OpenPaaS supports single sign-on(SSO) by external modules: LemonLDAP: provided by the linagora.esn.lemonldap module. OpenID Connect"
					}

					
				
			
		
			
				
					,
					

					"apis-auth-lemonldap": {
						"id": "apis-auth-lemonldap",
						"title": "SSO - LemonLDAP",
						"category": "",
						"url": " /apis/auth/lemonldap/",
						"content": "Table of contents Overview Getting started Install LemonLDAP::NG software Install LemonLDAP awesome module Configure LemonLDAP User provision Logout Logout from OpenPaaS then LemonLDAP Logout from LemonLDAP then OpenPaaS Overview OpenPaaS supports LemonLDAP authentication. If this is the first time you hear about LemonLDAP, check their website to explore that awesome software. LemonLDAP protects OpenPaaS behind a proxy. OpenPaaS then authenticates users by reading HTTP trusted-headers forwarded from LemonLDAP. See more about it here. When the user logs in to OpenPaaS, the following steps happen: The user goes to OpenPaaS and is redirected to login page of LemonLDAP The user enters credentials to log in and is redirected back to OpenPaaS OpenPaaS reads the trusted-headers forwarded from LemonLDAP, converts it to OpenPaaS user If the user is found in trusted-headers, OpenPaaS makes the user authenticated. It then stores the user object in database on first login or updates the existing user in database on next logins Getting started Install LemonLDAP::NG software First, you need to install LemonLDAP::NG software. Have a look here. Install LemonLDAP awesome module Clone the repository: git clone https: ci.linagora.com linagora lgs openpaas linagora.esn.lemonldap.git Go into the module directory and install module dependencies npm install --production Next, you need to enable LemonLDAP awesome module for OpenPaaS. To do it, create a symbol link of this module in modules directory of OpenPaaS ESN then enable it in local configuration: \"modules\": [ \"linagora.esn.account\", ... \"linagora.esn.lemonldap\" add this line ], Once enabled, this module will be loaded with OpenPaaS and ready to work. The next step is to configure LemonLDAP virtualhost to protect OpenPaaS. Configure LemonLDAP To configure LemonLDAP, you must login to LemonLDAP manager page. Add virtual host LemonLDAP::NG configuration is built around Apache or Nginx virtual hosts. Each virtual host is a protected resource, with access rules, headers, POST data and options. Have a look here to create virtual host in Apache Nginx In LemonLDAP Manager page, go to Virtual Hosts, click on Add virtualhost, then fill your Virtual host hostname. Access Rule In LemonLDAP Manager page, go to Virtual Hosts » &lt;your virtualhost&gt; » Access Rule, click on New rule, then fill: Commments: Protect home page Regular expressions: ^ $ Rules: accept In the same page, change the Default rule to unprotect to allow other resources of OpenPaaS to be accessible normaly from outside. User provision This module provisions users automatically on their first login. It converts the authenticated user information in trusted-headers to OpenPaaS user and creates a user instance on the storage layer (MongoDB). The converter needs a mapping to know which field in headers is corresponding to the user attribute in OpenPaaS. You can configure this mapping in global configuration. The configuration is applied for the whole application so it must be platform-wide configuration: \"domain_id\" : null, \"modules\": [{ \"name\": \"core\", \"configurations\": [...] }, { \"name\": \"linagora.esn.lemonldap\", \"configurations\": [{ \"name\": \"mapping\", \"value\": { \"ll-auth-user\": \"auth-user\", required, mapping for unique username (usually email) \"ll-auth-domain\": \"auth-domain\", required, mapping for user domain \"lastname\": \"auth-name\", \"main_phone\": \"auth-phone\", ... } }, { ... }] }] Logout When the user logs out from OpenPaaS, he should be logged out from LemonLDAP and vice versa, when the user logs out from LemonLDAP, he should be logged out from OpenPaaS. Logout from OpenPaaS then LemonLDAP To achieve this behaviour, OpenPaaS redirects the user to a logout endpoint of LemonLDAP after his logout from OpenPaaS, hence the user is fully logged out from both services. You can configure the logout endpoint in platform-wide configuration, it looks like: \"domain_id\" : null, \"modules\": [{ \"name\": \"core\", \"configurations\": [...] }, { \"name\": \"linagora.esn.lemonldap\", \"configurations\": [{ \"name\": \"logoutUrl\", \"value\": \"http: auth.yoursite.com ?logout=1\" }, { ... }] }] That logout endpoint is something like http: auth.yoursite.com ?logout=1 depending on your LemonLDAP setup. Logout from LemonLDAP then OpenPaaS Once the user logs out from LemonLDAP, it then forwards the logout to other applications to close their sessions. LemonLDAP has a logout forward mechanism, that will add a step in logout process, to send logout requests (indeed, GET requests on application logout URL) inside hidden iframes. In LemonLDAP Manager page, go to General parameters » Advanced parameters » Logout forward and click on Add a key, then fill: Key: application name, e.g. OpenPaaS Value: OpenPaaS logout URL, e.g. http: openpaas.yoursite.com logout Note that the request on logout URL will be sent after user is disconnected, so you should unprotect this URL if it is protected by a LemonLDAP Handler. Forturnately, this is done above by setting the Default rule to unprotect."
					}

					
				
			
		
			
				
					,
					

					"apis-auth-oidc": {
						"id": "apis-auth-oidc",
						"title": "OpenID Connect",
						"category": "",
						"url": " /apis/auth/oidc/",
						"content": "Table of contents Overview Authenticating incoming REST API calls API Configuration Authenticating users Configuration OIDC Configuration User provisioning OIDC Servers Keycloak Overview OpenPaaS supports OpenID Connect (OIDC) as Authentication Authorization module. OIDC can be used to authenticate users when they reach OpenPaaS ESN and when they launch an OpenPaaS powered application: User is redirected to the OIDC login page, authenticates, and is then redirected to the initial application. The current page describes how to configure and use OIDC to provide this Single Sign On (SSO) support in OpenPaaS. Authenticating incoming REST API calls In order to allow applications to call OpenPaaS APIs, the OIDC strategy must be enabled on the OpenPaaS ESN backend. The current section explains how to configure it. API Configuration The oidc strategy must be added to the list of API strategies in the config default.*.json file: \"auth\": { \"apiStrategies\": [\"basic-mongo-ldap\", \"basic-mongo\", \"oidc\", \"bearer\", \"jwt\"] } This strategy will: Get the Bearer token from the incoming HTTP request Try to retrieve the user from the token by requesting the OIDC server “Mount” the OpenPaaS user from retrieved OIDC user email Pass the request to the next handler In order to retrieve the user from the token by requesting the OIDC server, OpenPaaS needs to be configured correctly: Configuration is described in the OIDC Configuration below. Authenticating users OIDC can also be used for SSO at the OpenPaaS portal level: The user will be redirected to the OIDC login page when required. In order to achieve this, OpenPaaS must be configured and the linagora.esn.oidc module must be enabled. Once done, the user will be redirected to the OIDC login logout pages when needed. Configuration The linagora.esn.oidc module must be added and enabled. Check the instructions here https: github.com linagora linagora.esn.oidc. The configuration is described in the OIDC Configuration section below. OIDC Configuration The configuration is platform-wide and so has to be set in the core module in the oidc settings: { \"name\": \"core\", \"configurations\": [ { \"name\": \"oidc\", \"value\": { \"issuer_url\": \"http: localhost:8888 auth realms master\", \"client_id\": \"openpaas\", \"client_secret\": \"34b398b7-79fe-4ab1-b53c-b68c20743558\", \"authorization_url\": \"http: localhost:8888 auth realms master protocol openid-connect auth\", \"token_url\": \"http: localhost:8888 auth realms master protocol openid-connect token\", \"user_info_url\": \"http: localhost:8888 auth realms master protocol openid-connect userinfo\", \"end_session_endpoint\": \"http: localhost:8888 auth realms master protocol openid-connect logout\" } }, ... ] } Where: issuer_url is the Issuer URL of your OIDC server client_id is the ID of the client you configured in the OIDC server client_secret is the unique, generated secret provided by the OIDC server authorization_url is the authorization endpoint token_url is the token endpoint user_info_url is the token to fetch user information end_session_endpoint is the URL used to end the user session (Spec) These values are available on distinct locations based on the OIDC server you use. More details are given below. IMPORTANT: For now, all the applications (OpenPaaS ESN and Vue applications) are sharing the same client_id and MUST BE configured as is. User provisioning When delegating authentication to OIDC, the users will be provisioned in the OpenPaaS backend when required: When OpenPaaS ESN is loading user at login When OpenPaaS application is calling REST APIs In order to provision the user in the right domain, OpenPaaS will rely on the email address provided by the OIDC UserInfo endpoint and provision following these steps: Extracting the email Top-Level Domain (TLD) Searching a domain with the name from email address TLD If domain found then create a user in this domain Else do not provision user For example, if the user email address is name@open-paas.org, search a domain with name open-paas.org then create user in this domain if it exists, else fail. OIDC Servers The current section will give details on how to use and configure OIDC self-hosted servers as part of a development process. This is not supposed to be used as-is in production environments. Keycloak Keycloak is an Open Source Identity and Access Management which can be used as OIDC server. In the following instructions, it is assumed that Keycloak has is running on port 8888 and that we are using the master realm i.e. docker run -p 8888:8080 jboss keycloak The easiest way to go is to use Docker as described in the Docker Hub page. Once logged in as admin, you should have access to the realm configuration page on http: localhost:8888 auth admin master console # realms master. In order to use OpenID Connect in OpenPaaS, you will have to create a Client in keycloak: Go to Clients, then click on Create. Set openpaas as Client ID Toggle Consent Required to ON Toggle Display client on consent screen to ON Toggle Implicit Flow Enabled to ON Set Access Type to confidential Every time an application will have to use this OIDC client, you will have to update the Valid redirect URIs by adding the application ones. As an example, for OpenPaaS Vue applications, you have to add 2 redirect URLs each time. If the application is running at http: localhost:8081: http: localhost:8081 oidc-callback http: localhost:8081 login http: localhost:8080 http: localhost:8080 linagora.esn.oidc callback Note: For development purposes you can define redirect URLs with wildcards like http: localhost:8080 * and http: localhost:8081 * You also have to add Web origins to allow CORS based on your application deployment. For development purposes, * is enough. Click on Save 10.You can now get the client_secret from the Credentials tab: You can now configure OpenPaaS by putting the right value in platform configuration. For example, from the screenshots above, and if keycloak is running on port 8888: { \"name\": \"oidc\", \"value\": { \"issuer_url\": \"http: localhost:8888 auth realms master\", \"client_id\": \"openpaas\", \"client_secret\": \"96a97f8d-2a73-46e2-b602-512e034ea5f0\", \"authorization_url\": \"http: localhost:8888 auth realms master protocol openid-connect auth\", \"token_url\": \"http: localhost:8888 auth realms master protocol openid-connect token\", \"user_info_url\": \"http: localhost:8888 auth realms master protocol openid-connect userinfo\", \"end_session_endpoint\": \"http: localhost:8888 auth realms master protocol openid-connect logout\" } } In order to get user information from their access token, keycloak needs to be configured to have the same users as the ones available in OpenPaaS. Check the keycloak documentation for more information on this. For development purposes, you can create users by hand in keycloak and use them in your daily development process: Go to Users Click on Add user Fill the form, be sure to put the same email as the one you have in OpenPaaS user database Click on Save Go in the Credentials tab, then set a New password and Password confirmation Toggle Temporary to OFF Hit Enter to save If you have a LDAP directory running somewhere in your environment, you can also use the keycloak user federation feature and import your LDAP users. Check the keycloak documentation for more details at https: www.keycloak.org docs 6.0 server_admin #_ldap."
					}

					
				
			
		
			
				
					,
					

					"apis-swagger": {
						"id": "apis-swagger",
						"title": "Swagger",
						"category": "",
						"url": " /apis/swagger/",
						"content": "Loading API documentation ..."
					}

					
				
			
		
			
				
					,
					

					"apis-web": {
						"id": "apis-web",
						"title": "Web API",
						"category": "",
						"url": " /apis/web/",
						"content": "Table of contents Overview Basics Authentication Pagination Overview The OpenPaaS Web API allows you to build applications that interact with OpenPaaS in more complex ways than the integrations we provide out of the box. Basics Authentication There are several ways to authenticate users through OpenPaaS API as described in the Auth section. Pagination Request that return multiple items can be paginated. You can specify an offset with the offset query parameter and the number of elements can be defined by using the limit one. curl 'https: HOST:PORT api RESOURCE?limit=50&amp;offset=20' This request will return 50 items starting at the 20th one i.e. from 20 to 69."
					}

					
				
			
		
			
				
					,
					

					"core-configuration": {
						"id": "core-configuration",
						"title": "Configuration",
						"category": "",
						"url": " /core/configuration/",
						"content": "Table of contents Local configuration Overview Usage Global configuration Overview Configuration scope Configuration inheritance Usage OpenPaaS has two types of configuration: Local: Defines the local configurations of the current instance Global: Defines the configuration which is shared between on all the OpenPaaS instances Local configuration Overview Local configuration of the application is stored in the config default.json file. You should not modify this file directly but instead define the environment-based configuration file, e.g. config default.dev.json for development and config default.production.json for production deployment. The application relies on NODE_ENV environment variable to know which configuration file to be loaded. For example, if NODE_ENV=test, it will load config default.test.json file. Note that the configuration defined in . config default.json will not be overridden by the environment-based configuration file but instead inherited from it. The only exception is the array propertices, which will be overridden. Usage The local configurations are stored in JSON structure so it is pretty easy to read and write this type of configuration. To read configurations, simply require the module in backend core config: const config = require('...')('default'); console.log(config.auth.strategies); Since it is stored in file system, you simply modify the file to modify the configurations. Global configuration Overview The global configuration is stored in MongoDB under the configurations collection in order to be shared over nodes. A configurations document has the following structure: { \"domain_id\" : ObjectId(\"domain_id\"), \"user_id\" : ObjectId(\"user_id\"), \"modules\" : [ { \"name\" : \"module name\", \"configurations\" : [ { \"name\" : \"config_name\", \"value\" : Any }, { ... } ] }, { other modules } ] } Configuration scope Each document has its scope, base on the values of domain_id and user_id: User-wide: configurations belong to a specific user in a specific domain, the document must contain both domain_id and user_id Domain-wide: configurations belong to a specific domain, the document must contain domain_id and no user_id System-wide (AKA platform-wide): configurations which will be applied to the whole system, the document must not contain neither domain_id or user_id Configuration inheritance The global configuration has a concept of inheritance, which means if there is no configuration in a scope, the configuration in wider scope will be used. For example, if the user does not specify any configuration, the configuration of his current domain will be used. And so on, if the configuration of a domain is not specified, the system-wide configuration will be used. Usage In both frontend and backend, the global configurations can be read by esn-config module. In backend, the code is placed in backend core esn-config: const esnConfig = require('..'); get system-wide configuration esnConfig('mail') .inModule('core') .get() .then((config) =&gt; { console.log(config); }); get domain-wide configuration esnConfig('mail') .inModule('core') .forUser(user) .get() .then((config) =&gt; { console.log(config); }); get user-wide configuration const userWide = true; esnConfig('mail') .inModule('core') .forUser(user, userWide) .get() .then((config) =&gt; { console.log(config); }); In frontend, you simply inject the esnConfig service to get the configuration, the API is a bit different: esnConfig('core.datetime').then(function(config) { console.log(config); });"
					}

					
				
			
		
			
				
					,
					

					"core-eventsourcing": {
						"id": "core-eventsourcing",
						"title": "EventSourcing",
						"category": "",
						"url": " /core/eventsourcing/",
						"content": "Table of contents Events Events Almost all actions in the OpenPaaS platform produce events, most of them are published in the local pubsub channel to allow extensibility and reactivity. A first implementation stores every event published in any pubsub topic in the Elasticsearch platform instance in the core.events.idx index (Data can then be visualized using Kibana)."
					}

					
				
			
		
			
				
					,
					

					"core-health-check": {
						"id": "core-health-check",
						"title": "Health Check",
						"category": "",
						"url": " /core/health-check/",
						"content": "Table of contents Overview REST API GET api healthcheck: Authentication: Response Schema Status GET api healthcheck :name: Authentication: Request Response Schema Status GET api healthcheck services: Authentication: Response Schema Status For developers Register a new health check provider HealthCheckProvider Checker function Register function Get registered services Retrieve health status of services Overview The Health check API represents your OpenPaaS health status. You can use it to monitor services in OpenPaaS. REST API The health check API is used to retrieve health status of services. GET api healthcheck: Query for all services health status. Authentication: This API provides two kinds of information: Public: Global status of all services. Private: Advance information of services. User must authenticate as a platform admin to retrieve this kind of information. Response Schema Public Response { \"status\": \"healthy\" } Private Response { \"status\": \"unhealthy\", \"checks\": [ { \"componentName\": \"mongodb\", \"status\": \"healthy\", \"details\": null }, { \"componentName\": \"redis\", \"status\": \"healthy\", \"details\": null }, { \"componentName\": \"rabbitmq\", \"status\": \"healthy\", \"details\": null }, { \"componentName\": \"elasticsearch\", \"status\": \"healthy\", \"details\": null }, { \"componentName\": \"ldap\", \"status\": \"unhealthy\", \"details\": { \"cause\": \"Health check: Something went wrong with LDAP connection.\", \"info\": [ { \"configuration\": { \"mapping\": {}, \"url\": \"dummy\", \"adminDn\": \"test\", \"adminPassword\": \"test\", \"searchBase\": \"test\", \"searchFilter\": \"(test=)\" }, \"usage\": { \"auth\": true, \"search\": true, \"autoProvisioning\": true }, \"name\": \"test\", \"domainId\": \"5e9888463662616055f5c3be\", \"state\": \"unhealthy\", \"message\": \"dummy is an invalid LDAP URL (protocol)\" } ] } } ] } status: Global status of all services, can be healthy or unhealthy. healthy: All services work normally. unhealthy: One or more service is currently not working or under an unstable condition. checks: An array of health statuses. Child attributes: componentName (string): The name of the service component. status (string): Current status of the service, can be healthy or unhealthy. healthy: Service works normally. unhealthy: Service is currently not working or under an unstable condition. details: (object): Contain advance information of the service. Status 200 - OK: The check has answered with a global healthy status. 503 - Service Unavailable: The check has answered with a global unhealthy status. GET api healthcheck :name: Query for a single service health status. Authentication: This API requires user to authenticate as a platform admin in order to retrieve information. Request This API accepts one parameter as the name of the service. The name parameter is case-insensitive. api healthcheck mongodb To get a list of available service names for performing health check, please refer to API GET api healthcheck services as described below. Response Schema { \"componentName\": \"ldap\", \"status\": \"unhealthy\", \"details\": { \"cause\": \"Health check: Something went wrong with LDAP connection.\", \"info\": [ { \"configuration\": { \"mapping\": {}, \"url\": \"dummy\", \"adminDn\": \"test\", \"adminPassword\": \"test\", \"searchBase\": \"test\", \"searchFilter\": \"(test=)\" }, \"usage\": { \"auth\": true, \"search\": true, \"autoProvisioning\": true }, \"name\": \"test\", \"domainId\": \"5e9888463662616055f5c3be\", \"state\": \"unhealthy\", \"message\": \"dummy is an invalid LDAP URL (protocol)\" } ] } } Where: componentName (string): The name of the service component. status (string): Current status of the service, can be healthy or unhealthy. healthy: Service works normally. unhealthy: Service is currently not working or in an unstable condition. details: (object): Contain advance information of the service. Status 200 - OK: The check has answered with a healthy status. 401 - Unauthorized: User has not logged in. 403 - Forbidden: User has not authenticated as a platform admin. 404 - Not Found: Service with the provided name cannot be found. 503 - Service Unavailable: The check has answered with a unhealthy status. GET api healthcheck services: Query for all available service names. Authentication: This API requires user to authenticate as a platform admin in order to retrieve information. Response Schema A response of this API can be fully defined like this: { \"services\": [\"mongodb\", \"redis\", \"rabbitmq\", \"elasticsearch\"] } services : An array of available service names. Status 200 - OK: API is working normally, returns a list of available service names. 401 - Unauthorized: User has not logged in. 403 - Forbidden: User has not authenticated as a platform admin. 500 - Server Errors: Internal Server Error. For developers Register a new health check provider The health check module is available at backend core health-check. To register a service as a health check provider, we should separate the logic into a file health-check.js. For each service we have a separated heath-check.js file. HealthCheckProvider HealthCheckProvider is a class used to modelize services. Its constructor requires the name of the service and a function called checker. The checker function will be defined in detail next section. const { HealthCheckProvider } = dependencies('health-check'); new HealthCheckProvider(SERVICE_NAME, checker); Checker function Checker is an async function. Its main purpose is to call for some APIs Methods Functions to check for status of service, then return a promise contains formatted messages. We created 2 helper functions to build formatted messages for checker: buildHealthyMessage and buildUnhealthyMessage function checker() { return checkConnection() .then(result =&gt; (result ? buildHealthyMessage(SERVICE_NAME) : buildUnhealthyMessage(SERVICE_NAME, message))) .catch(error =&gt; { return buildUnhealthyMessage(error); }); } In the example provided above, we call a function to check for the connection of service, then build the formatted message and return it. Each service has its own functions methods or APIs to check for health or connection status. Register function To make a service available for health check API, call the register method inside the init function of that service: const { registry } = dependencies('health-check'); Here we declare the register function to call inside the init function of the service we want to register as a Health Check Provider. function register() { return registry.register(new HealthCheckProvider(SERVICE_NAME, checker)); } module.exports = { register } After that, import and call the function where the service was initialized. const healthCheck = require('. health-check'); healthCheck.register(); After registered successfully, your service will be available via the Health Check API. Get registered services In case you want to get all registered services, call the getRegisteredServiceNames method: const { getRegisteredServiceNames } = dependencies('health-check'); getRegisteredServiceNames(); ['mongodb', 'rabbitmq', 'redis', 'elasticsearch'] Retrieve health status of services Health check module provides you 2 methods to get the health status of services, check and checkWithDetails. These two return a promise which contains the formatted result of services. const { check, checkWithDetails } = dependenies('health-check'); check().then((result) =&gt; { Do something with the result here }); checkWithDetails(['mongodb', 'elasticsearch']).then((result) =&gt; { Do something with the result here }); Those two functions accept a parameter, serviceNames. The parameter is an array of service names that function will return the result for. If unset, functions will return the status of all services registered. The difference between check and checkWithDetails is check does not return data with details field, while checkWithDetails does. This provides us the ability to protect the sensitive data, prevent it from exposing to unnecessary client."
					}

					
				
			
		
			
				
					,
					

					"core-i18n": {
						"id": "core-i18n",
						"title": "I18n",
						"category": "",
						"url": " /core/i18n/",
						"content": "Table of contents Where are the locale files? Backend translation Translate static string in .pug files Translate string in Node.js files Frontend translation Translate Angular variable in .pug files Translate string in Javascript files Translation validator Internationalization (i18n) is the process of developing products in such a way that they can be localized for languages and cultures easily. OpenPaaS supports i18n completely in both backend and frontend sides: In backend, we use i18n-node In frontend, we use angular-translate Where are the locale files? Locale files of the core module can be found in backend i18n locales directory. Each module can have its own locale files, usually placed in backend lib i18n locales directory as in Calendar module for example. Currently, supported languages are English, French and Vietnamese. Backend translation When to use: Translate static string in .pug files Translate string in Node.js files, for example: translate an email before sending it to recipients. Translate static string in .pug files It is pretty easy to translate phrases in .pug files: h2 #{__('Good morning!')} Simple string interpolation: h2 #{__('Hello %s, good morning!', 'John')} Angular expression string interpolation: h2 #{__('Hello %s, good morning!', '{{user.name}}')} HTML string interpolation: p.empty-text !{__('No application, click %s to add a new one', '&lt;span class=\"mdi mdi-plus\"&gt;&lt; span&gt;')} Translate string in Node.js files Simply require the module in backend core i18n: const i18n = require('...'); const subject = i18n.__('Your password has been changed!'); Check the documentation of i18n-node for more examples. Frontend translation When to use: Translate Angular variable in .pug files Translate string in Javascript files You can either use esnI18n filter or esnI18nService of esn.i18n module to translate your phrases. Translate Angular variable in .pug files span {{mailbox.name | esnI18n}} Translate string in Javascript files inject the esnI18nService service var subject = esnI18nService.translate('Email sent to %s', $scope.recipient.email).toString(); The esnI18nService.translate function returns an instance of EsnI18nString, which will be useful when you want to know whether the string is translated or not: function notify(message) { message = esnI18nService.isI18nString(message) ? message.toString() : esnI18nService.translate(message).toString(); window.alert(message); } Usage notify('Hello world!'); OR notify(esnI18nService.translate('Hello %s!', user.name)); Translation validator OpenPaaS uses a built-in validator based on i18n-checker package to ensure the quality of internationalization in product. To use the validator, simply run: grunt i18n"
					}

					
				
			
		
			
				
					,
					

					"core-people": {
						"id": "core-people",
						"title": "People API",
						"category": "",
						"url": " /core/people/",
						"content": "Table of contents Overview API Register provider Searcher Resolver REST API POST api people search GET api people resolve {:fieldType} {:value} Overview The OpenPaaS Core provides the people API which is used to: Search accross several people-related sources: members, contacts, resources, groups, … Get a resolved person by finding a matching object from a particular field (e.g email address) API The people API is used to retrieve persons. A person is a resource which can be defined like this: { \"id\": \"5bf7d8ccb4177e001c8a1efe\", \"objectType\": \"user\", \"emailAddresses\": [ { \"type\": \"work\", \"value\": \"brucewillis@open-paas.org\" } ], \"names\": [ { \"type\": \"principal\", \"displayName\": \"Bruce Willis\" } ], \"photos\": [ { \"type\": \"main\", \"url\": \" users api 123 avatar\" } ] } Register provider Searcher The people module is available at backend core people. The people module uses ‘searchers’ to lookup to persons and send them back in the right format. Searchers can be registered like this: const { service, Model, PeopleSearcher } = dependencies('people'); const userSearcher = new PeopleSearcher('user', searcher, denormalizer, priority); service.addSearcher(userSearcher); Where searcher is a function which returns a Promise which resolves with an Array of resources: function resolver({ term, context, pagination }) { const options = { search: term, domains: [context.domain], limit: pagination.limit }; return new Promise((resolve, reject) =&gt; { search(options, (err, result) =&gt; { if (err) { return reject(err); } result &amp;&amp; result.list ? resolve(result.list) : resolve([]); }); }); } Where denormalizer is a function which returns a Promise which resolves with a Model.Person from an element coming from the resolver result: function denormalizer({ source }) { const denormalized = denormalize(source); const email = new Model.EmailAddress({ value: source.email, type: 'default' }); const name = new Model.Name({ displayName: `${source.firstName} ${source.lastName}` }); const photo = new Model.Photo({ url: ` api avatars ${source._id} avatars` }); return Promise.resolve( new Model.Person({ id: denormalized._id, objectType: 'user', emailAddresses: [email], names: [name], photos: [photo] }) ); } and where priority is the resolver priority. Higher priority means sending back these resolver results first in the list. Resolver The people module use resolver to find exactly a person that has a property field matched with the given value. Following the searcher format, resolver can be registered like this: const { service, Model, PeopleResolver } = dependencies('people'); const userResolver = new PeopleResolver('user', resolver, denormalizer, defaultPriority); service.addResolver(userResolver); Where resolver is a function which returns a Promise which resolves with only at most one resource. function resolver({ fieldType, value, context }) { if (fieldType === FIELD_TYPES.EMAIL_ADDRESS) { return new Promise((resolve, reject) =&gt; { findByEmail(value, { domainId: context.domain._id}, (err, user) =&gt; { if (err) return reject(err); resolve(user); }); }); } return Promise.resolve(); } The priority of each resource type is determined by API users, the defaultPriority property will be used when the prioritized order is not provided by API users. REST API POST api people search Search for persons on various types Request Body { \"q\": \"bruce\", \"objectTypes\": [\"user\", \"contact\", \"ldap\"] \"limit\": 10, } q is the text to search in persons objectTypes are the types of person to look for limit is the max number of resources to send back per objectType Response [ { \"id\": \"5bf7d8ccb4177e001c8a1efe\", \"objectType\": \"user\", \"emailAddresses\": [ { \"type\": \"work\", \"value\": \"brucewillis@open-paas.org\" } ], \"names\": [ { \"type\": \"principal\", \"displayName\": \"Bruce Willis\" } ], \"photos\": [ { \"type\": \"avatar\", \"url\": \"https: open-paas.org api users 5bf7d8ccb4177e001c8a1efe avatar\" } ] }, { \"id\": \"5bf7d8ccb4177e001c8a1eff\", \"objectType\": \"contact\", \"emailAddresses\": [ { \"type\": \"home\", \"value\": \"brucelee@open-paas.org\" } ], \"names\": [ { \"type\": \"principal\", \"displayName\": \"Bruce Lee\" } ], \"photos\": [ { \"type\": \"avatar\", \"url\": \"https: open-paas.org api users 5bf7d8ccb4177e001c8a1eff avatar\" } ] } ] GET api people resolve {:fieldType} {:value} Retrieve a single resolved object that have a field matching specific value Parameters fieldType: the field to find the resolved object (e.g emailAddress) value: the value to query Request Query Parameters objectTypes: A list of object types to find the matching objects and also the priority order for resolving process Optional, by default resolver will handle all object types by orders: user, group, contact. Supported object types for the moment are user, contact, group. Response: { \"id\": \"5bf7d8ccb4177e001c8a1efe\", \"objectType\": \"user\", \"emailAddresses\": [ { \"type\": \"work\", \"value\": \"brucewillis@open-paas.org\" } ], \"names\": [ { \"type\": \"principal\", \"displayName\": \"Bruce Willis\" } ], \"photos\": [ { \"type\": \"avatar\", \"url\": \"https: open-paas.org api users 5bf7d8ccb4177e001c8a1efe avatar\" } ] }"
					}

					
				
			
		
			
				
					,
					

					"core-provisioning": {
						"id": "core-provisioning",
						"title": "Provisioning",
						"category": "",
						"url": " /core/provisioning/",
						"content": "Table of contents Overview Platform Administrator Overview OpenPaaS resources can be provisioned from several sources. This chapter details them. Platform Administrator In order to be able to do management operations, a platform administrator is needed. A platform administrator can be provisioned from environment variables: INIT_PLATFORMADMIN_USERNAME: The email to be used for the platform administrator account INIT_PLATFORMADMIN_PASSWORD: The password to be used for the platform administrator account If, and only if, there are no platform administators defined in OpenPaaS, a new platform administrator will be created at startup from these environment variables."
					}

					
				
			
		
			
				
					,
					

					"core-pubsub": {
						"id": "core-pubsub",
						"title": "Pubsub",
						"category": "",
						"url": " /core/pubsub/",
						"content": "Table of contents Overview API Subscribe Publish Local pubsub Global pubsub Overview The OpenPaaS Core provides several publish subscribe components: local: Events published in this pubsub component will only be delivered to the same local OpenPaaS instance listeners global: Events published in this pubsub component will be delivered to all the OpenPaaS instance listeners API Both local and global pubsub are providing the same API. Getting a pubsub instance is as easy as getting it from the OpenPaaS dependencies manager: const {local, global} = dependencies('pubsub'); Once you have the instance, you can subsribe and publish events. Subscribe const pubsub = dependencies('pubsub').local; pubsub.topic('my:topic').subscribe(event =&gt; { console.log('This will be called when event is published in topic', event); }); Publish const pubsub = dependencies('pubsub').local; const event = {id: 1, data: {}}; pubsub.topic('my:topic').publish(event); Local pubsub The local pubsub is built using the Node.js EventEmitter. This means that any object can be published in this pubsub component but it is highly encouraged to publish Event instances: const pubsub = dependencies('pubsub').local; const { Event } = dependencies('models'); https: github.com linagora openpaas-esn blob master backend core models event.js const e = new Event( * Check the doc for args * ) pubsub.topic('my:topic').publish(e); Global pubsub The global pubsub is built using RabbitMQ as message broker. This allows OpenPaaS to use and rely on all the mechanisms provided by RabbitMQ and so have some high warranty level delivering messages. Note: It is recommended to push only JSON data in the global pubsub."
					}

					
				
			
		
			
				
					,
					

					"core-search": {
						"id": "core-search",
						"title": "Search",
						"category": "",
						"url": " /core/search/",
						"content": "Table of contents Overview Indexing data Search data Frontend representation Prepare the services Prepare the provider Overview The OpenPaaS Core provides a search module which relies on Elasticsearch. This page will provides all the informations for a developer to use the core module in order to index and search data. Indexing data The core elasticsearch module provides a listeners module which must be used to register a listener. This listener will be in charge of handling everything needed to transform data from OpenPaaS to Elasticsearch, indexing data to the right place, etc… Registering a listener in the search module is as easy as giving a valid object. As an example, let’s say that we want to index messages coming from a chat module: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const listeners = dependencies('elasticsearch').listeners; listeners.addListener({ events: { add: 'message:create', update: 'message:update', remove: 'message:delete' }, denormalize: (message) =&gt; { do something with input data (coming from topic defined above) then return the data to be indexed return { text: message.message, date: message.timestamps.created_at }; }, getId: (message) =&gt; message._id.toString(), type: 'message', index: 'message.idx' }); events: The listener will listen on several events coming from the pubsub module as defined in lines 5 to 9. The listener automatically subscribe to the topics defined (message:create, message:update and message:remove) and will do whatever needed: Index data on a create event, update indexed data on an update event, delete indexed data on a remove event. The only thing needed for the developer here is to publish data on the right topic. denormalize: This function is called each time a data is created or updated to transform data into a JSON object which will be indexed in Elasticsearch. getId: This function is called on create, update, remove to determine the identifier of the document in Elasticsearch based on input data type: The type of data defined in Elasticsearch index: The Elasticsearch index where data is indexed Note that calling addListener will return a set of functions you can also use to make calls to Elasticsearch yourself: 1 2 3 4 5 6 const { listeners } = dependencies('elasticsearch'); const searchHandler = listeners.addListener(x); searchHandler.indexData(data, callback) searchHandler.removeFromIndex(data, callback) Once the listener is registered, indexing data is as easy as: 1 2 3 4 5 6 7 8 9 const { local } = dependencies('pubsub'); const message = { message: 'This is a wonderful message', timestamps: { created_at: new Date() } }; local('message:create').publish(message); The listener will be called automatically, and message will be indexed into Elasticsearch. Search data Making calls to Elasticsearch must be achieved from the elasticsearch module with the searchDocuments function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const elasticsearch = dependencies('elasticsearch'); const query = {}; some ES query https: www.elastic.co guide en elasticsearch reference current search.html elasticsearch.searchDocuments({ index: 'message.idx', type: 'message', from: 0, size: 10, body: query }, (err, result) =&gt; { if (err) { return console.log('I failed to search messages', err); } console.log('Search results', result.hits.hits); }); This will search messages in the message.idx index in the Elasticsearch service and return the search results. Frontend representation With a search function as above, we can provide an API endpoint for searching documents. In front-end side, for a document can be search via OpenPaaS header, there must be a registration to provide the search service or document name, types, search result templates,… Prepare the services First, we need an Angular service to handle request sending. We continue with message searching example, now with an API as GET api messages?search=term, our search service would look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 angular.module('your.module') configure restangular .factory('messageRestangular', function(Restangular) { return Restangular.withConfig(function(RestangularConfigurer) { RestangularConfigurer.setBaseUrl(' api'); RestangularConfigurer.setFullResponse(true); }); }) send request to search API .factory('searchMessageService', function(messageRestangular) { return { searchMessages }; function searchMessages(term) { return messageRestangular.all('messages').getList({search: term}); } }); Prepare the provider For every types of documents, OpenPaaS has an Angular service called searchProviders to contain documents search registration. We define our messageSearchProvider as following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 angular.module('your.module') .factory('messageSearchProvider', function($q, newProvider, searchMessageService) { return newProvider({ name: 'Messages', fetch: function(term) { return searchMessageService(term) .then(function(response) { return response.data; }) }, buildFetchContext: function(options) { return $q.when(options.query); }, templateUrl: ' path to your search result template.html' }); }); name: the document name that is displayed in search header fetch: a function that will fetch the search result from API response buildFetchContext: build the context before fetching results templateUrl: the template for search results display Then, we register the messageSearchProvider to searchProviders by: 1 2 3 4 angular('my.module') .run(function(searchProviders, messageSearchProvider) { searchProviders.add(messageSearchProvider); }); As a result, the document can be selected and searched respectively via the search header."
					}

					
				
			
		
			
				
					,
					

					"dev-debug": {
						"id": "dev-debug",
						"title": "Debug",
						"category": "",
						"url": " /dev/debug/",
						"content": "Table of contents ESN Backend ESN Backend Thanks to Node.js debugging tools, it is possible to debug the ESN backend by adding the --inspect flag on start: ENV=dev node --inspect server.js The process will start and will first print debugger information like: Debugger listening on ws: 127.0.0.1:9229 dd36b398-43ce-419b-8c0f-207c07365672 For help see https: nodejs.org en docs inspector debug: local SUBSCRIBE to mongodb:connectionAvailable On recent version of Google Chrome, you will be able to open the Node.js debugger from: chrome: inspect #devices then click on inspect under server.js From the Developer Tools by clicking on the DevTools for Node.js green icon When done, you are able to go to the sources tab, add breakpoints, and debug as you can do when debugging frontend code."
					}

					
				
			
		
			
				
					,
					

					"devops-james": {
						"id": "devops-james",
						"title": "James",
						"category": "",
						"url": " /devops/james/",
						"content": "Table of contents Overview Choose your James distribution Overview James is the OpenPaaS mail server. Choose your James distribution James is built providing different distributions. The James packages include for the moment two distributions: James without LDAP (default) James with LDAP support You can choose which distribution you want to use by running the following command: # update-alternatives --config james"
					}

					
				
			
		
			
				
					,
					

					"devops-kibana": {
						"id": "devops-kibana",
						"title": "Kibana",
						"category": "",
						"url": " /devops/kibana/",
						"content": "Table of contents Overview Run with Docker Overview Kibana is a tool we use to visualize and navigate into Elasticsearch data. Run with Docker The Elasticsearch version used in OpenPaaS does not allow to use the latest Docker image for Kibana. Here are the instruction to run a valid Kibana version with Docker: docker run -d -e \"ELASTICSEARCH_URL=http: HOST:POST\" -p 5601:5601 kibana:4.5 Where ELASTICSEARCH_URL is the URL of the Elasticsearch instance you want Kibana to connect to (i.e. the URL the Kibana container can reach). Once started, you can open the Kibana Web UI from http: localhost:5601 :"
					}

					
				
			
		
			
				
					,
					

					"frontend-i18n": {
						"id": "frontend-i18n",
						"title": "I18n",
						"category": "",
						"url": " /frontend/i18n/",
						"content": "Table of contents Where are the locale files? How it Work Js files Vue files Internationalization (i18n) is the process of developing products in such a way that they can be localized for languages and cultures easily. We use vue-i18n Where are the locale files? Locale files can be found in src i18n lang directory. Currently, supported languages are English, French and Vietnamese. How it Work Js files Import your language file into src i18n index.js. import en from \"@ i18n lang en.json\"; Add it to the messages object. export const i18n = new VueI18n({ locale: 'en', messages: { en } }); Vue files It is pretty easy to translate phrases in .vue files: &lt;h1&gt;{{ $t('OpenPaaS Login') }}&lt; h1&gt; Atribute syntax: Use v-bind or the : shortcut with $t('some text') &lt;v-text-field name=\"login\" :label=\"$t('Login')\" type=\"text\" &gt;&lt; v-text-field&gt; Check the documentation of vue-I18n and vue-I18n starter for more examples."
					}

					
				
			
		
			
				
					,
					

					"frontend-vue-auth": {
						"id": "frontend-vue-auth",
						"title": "Vue Authentication",
						"category": "",
						"url": " /frontend/vue-auth/",
						"content": "Table of contents Overview Application Configuration Variables Vue router Basic Authentication Configuration OpenID Connect Authentication Configuration Overview There are 2 ways to authenticate users in Vue applications: Rely on Basic Authentication (login password) and JWT token Rely on OpenID Connect (OIDC) OpenID Connect has been chosen as the default authentication authorization module of the OpenPaaS platform. Basic Authentication is mainly keep to ease development of applications without having to deal with the OpenID Connect setup and configuration. Application Configuration Variables Switching between authentication methods is possible with the help of the VUE_APP_AUTH environment variable. Possible values are basic and oidc(defaults to basic). VUE_APP_AUTH=oidc npm run serve Vue router Routes are set to public private using the auth field in Route Meta Fields: export default new Router({ base: ApplicationSettings.BASE_URL, mode: \"history\", routes: [ { path: \" \", name: routeNames.HOME, component: Home, meta: { auth: true } } ] }); Basic Authentication On Basic Authentication mode, the user has to fill a login password form then: A HTTP call is made with Basic Authentication header to a JWT generation endpoint The JWT token is saved in the Vuex Store All the following HTTP calls will use this JWT token in the Authorization header OpenPaaS server will use this token to authenticate the user in the request process Configuration There is no specific configuration on the application side for Basic Authentication. OpenID Connect Authentication On OpenID Connect Authentication mode, the application will rely on the OpenID Connect Authorization server to manage the authentication and authorization workflows. As a result, the application will get a JWT token which will be used exactly like in the steps 2,3,4 of the Basic Authentication workflow. Configuration In order to use OIDC, the application needs to be configured to reach the OIDC server. This configuration has to be set in the src public env openpaas.js file. The oidc data is required in this mode: window.openpaas = { Define the authentication method to use: \"oidc\" or \"basic\" (defaults to \"basic\" when not defined) VUE_APP_AUTH: \"oidc\", OpenID Connect configuration oidc: { `authority` is the OpenID Connect Authority: lemonLDAP, keycloak, etc... authority: \"http: localhost:8888 auth realms master\", `clientId` is defined on the authority and needs to match the local one. A good practice is to have a generated string clientId: \"openpaas-seed\", `redirectUri` is the application URL the user agent is redirected after login on the authority server \" oidc-callback\" is the local Vue application route handling the redirect This redirect URI must be declared as valid redirect URI on the authority server client definition redirectUri: \"http: localhost:8081 oidc-callback\", `postLogoutUri` is the application URL the user agent is redirected after logout on the authority server \" login\" is the local Vue application route handling the redirect This redirect URI must be declared as valid redirect URI on the authority server client definition postLogoutRedirectUri: \"http: localhost:8081 login\", `responseType` is what is response types expected by the client responseType: \"id_token token\", `scope` are used by the application during authentication to authorize access to a user's details scope: \"openid email profile\" } } The configuration above assumes that the application is available on http: localhost:8081. This value has to be updated based on your application URL The authority URL has to be updated based on your OIDC server settings More details on how to setup OIDC on the OpenPaaS Platform are available in the OIDC page."
					}

					
				
			
		
			
				
					,
					

					"frontend-vue-components": {
						"id": "frontend-vue-components",
						"title": "Vue Components",
						"category": "",
						"url": " /frontend/vue-components/",
						"content": "Table of contents Overview Develop new components Use in development mode Overview A collection of Vue components are available to build Vue applications. Components are available at https: github.com linagora vue-openpaas-components and can be used as dependency in any other OpenPaaS Vue projects. npm install @linagora vue-openpaas-components Once installed, you can use them in your application by importing them: import Vue from 'vue'; import OpenPaaSComponents from '@linagora vue-openpaas-components'; Vue.use(OpenPaaSComponents); Components are then available and can be used in any other component. For example, to display an OpenPaaS user avatar with its online status: &lt;template&gt; &lt;op-avatar size=\"48\"&gt; &lt;!-- Slots are not yet available, will work on this later --&gt; &lt;op-status :status=\"user.status\" slot=\"bottom-right\"&gt; &lt; op-avatar&gt; &lt; template&gt; Develop new components To add new components, you will have to follow some conventions. For example, to create a xyz component: Always use the op prefix Create a folder named opXyz under src components Create your Vue component in a src components opXyz opXyz.vue file In src components opXyz index.js file, import your Vue component, then export it like import opXyz from '. opXyz.vue'; export { opXyz }; export default opXyz; In src components index.js, export your component export * from '. opXyz'; The component will be automatically registered as a global component and you will be able to use it like &lt;op-xyz &gt; Use in development mode While you are developing new components, you will need to link the current project in your Vue project with npm link: In this project run npm link In your project run npm link vue-openpaas-components"
					}

					
				
			
		
			
				
					,
					

					"frontend-vue": {
						"id": "frontend-vue",
						"title": "Vue.js",
						"category": "",
						"url": " /frontend/vue/",
						"content": "Table of contents Overview Dependencies Environment Bootstrap a new application 1. Clone the seed 2. Install dependencies 3. Configure 4. Develop Best practices Project files layout State Management Routing Authentication ESN-hosted application PaaS-hosted application JWT Cookies LemonLDAP Reusing components Using OpenPaaS Core API Build Deploy Build &amp; Run Overview We choose Vue.js as the framework to develop new Web applications within OpenPaaS. This page describes architecture, best practices and explain choices we made. Dependencies Here is the (uncomplete) list of dependencies used to build a Vue app: Vue, vue-router, vuex HTTP Client: axios, vue-axios Material design: Vuetify and so Stylus Templates: HTML, PUG with the help of the right loaders Auth: @websanova vue-auth Tests: Jest Environment We use latest Vue version, Vue CLI 3 and Node 10.x: You will need Node and we recommend using nvm to manage your Node version, so install it first if you do not already use it. Install Node 10 with nvm nvm install 10, then switch if needed nvm use 10 Install Vue CLI npm install -g @vue cli Bootstrap a new application A “seed” is available at https: github.com linagora vue-openpaas-seed. It uses all the dependencies listed above and provides an OpenPaaS compatible layout. By using this seed as basis for other apps, you will be sure to be compliant with all the good practices defined in this guide. 1. Clone the seed (Replace my-app by your app name) git clone git@github.com:linagora vue-openpaas-seed.git my-app You will have to change several things in the files, expecially the application name and description in package.json. 2. Install dependencies cd my-app npm install 3. Configure The application can be configured by updating the .env files as described in the Vue CLI documentation. Values defined in the .env file are used at several places in the app (from the store), and can be adapted to your environment. For example, while in development, you can redefine your OpenPaaS instance URL in a .env.development.local file which will never be commited (so you can also push secrets in it). VUE_APP_SUPER_SECRET=A super secret thing VUE_APP_OPENPAAS_URL=http: localhost:8080 4. Develop Once done, you can start developping: You can start the app in dev mode with npm run serve Or, use the Vue CLI UI vue ui and browse to your application. Best practices Project files layout We use the default layout provided by vue-cli: All the configuration files are at the root of the repository Application code is under src src App.vue and src main.js are the application entry point src *.* files are used to configure the application src components is used for ‘reusable components’ src services are business services: auth, API clients, everything which is not related to Vue src store is where the vuex store lives in. As defined in the Store section, we use modules in the store, so each module has its own folder like src store moduleA and src store moduleB src views is used for application ‘pages’. These views are the one which are used by the router. The views are using the components from src components State Management There are tons of articles around the Web to understand why managing state the Flux-way is easy and powerful. The choice was not hard, just because Vue is simple and provides just the right tools, Vuex is used as state manager, and we rely on the modular approach so that we can scale our app. As shown in src store : Routing vue-router is used as the application router. We use name-based routing as defined in https: router.vuejs.org guide essentials named-routes.html By using vue-auth, routes can be protected and so user will be redirected to the login page until he is authenticated. For example (from src router.js): export default new Router({ routes: [ { path: ' ', name: 'Home', component: Home, meta: { auth: true } }, { path: ' login', name: 'Login', component: Login, meta: { auth: false } } ] }); The user will be redirected to the Login page if he is not authenticated when opening the Home page. Authentication The authentication is a complex subject and depends on the way application are hosted in OpenPaaS. Basically, they can be hosted as any other traditional AngularJS application, i.e. in an OpenPaaS module which is served by the OpenPaaS ESN, or they can be hosted in their own ‘runtime’, for example, in a distinct container, or as static assets. ESN-hosted application As described in the ESN authentication documentation, AngularJS application relies on cookies to authenticate user: A session cookie is sent with each request. This will be the same if the Vue application is hosted on a module, if not, new authentication mechanisms have to be implemented in the Vue application. PaaS-hosted application By ‘PaaS-hosted’, it means that the application is not hosted in an OpenPaaS ESN NodeJS module. It is hosted somewhere else, in a Docker container, served by an Apache server, etc… JWT websanova@vue-auth is used to implement JWT based authentication: When a user fills his login password on the login page, a single POST api jwt generate request is sent to the OpenPaaS backend, to get a JWT token for the given user. The token is then pushed in the application state and reused in all HTTP calls to OpenPaaS. Cookies This is not available right now and it hardly depends on how application are deployed in OpenPaaS: If a user who is authenticated within OpenPaaS opens a Vue powered application running somewhere else in the PaaS, we should be able to not ask the password again and again. There are several ways to do this, one will be to push a JWT token in the cookie and extract this JWT token when the Vue application is launched. T O D O: This needs to be checked LemonLDAP T O D O: Check how Lemon can be used, (and is already used) Reusing components Some frontend components are available as described in Vue Components. If for some reason, you need a component which is not provided by this module but you think it will be useful to share, please consider adding it to the module. Using OpenPaaS Core API T O D O: We need a dedicated module. Build Building the application can be done from npm npm run build or from Vue UI. It will generate the application in the dist folder. Deploy Vue applications such as openpaas-videoconference-app which need to be deployed in Docker environment must follow some rules: The Docker image must contain the generated assets (from npm run build) The application must not be configured at build time but at run time. This means that we can not use vue-cli resources like .env files in this case The Vue application assets must be served by an HTTP server like nginx and exposed correctly by the container Build &amp; Run # Multistage build FROM node:10.13.0-alpine as build-stage WORKDIR app COPY package*.json . RUN npm install COPY . . RUN npm run build # Then to run FROM nginx:1.13.12-alpine as production-stage COPY --from=build-stage app dist usr share nginx html VOLUME [\" usr share nginx html env\"] EXPOSE 80 CMD [\"nginx\", \"-g\", \"daemon off;\"] The important point here is the Docker volume used to put files into the container at runtime. The files in usr share nginx html env folder is then used by the application to get all the variables needed to run. For a concrete example, check code in https: ci.linagora.com linagora lgs openpaas openpaas-videoconference-app merge_requests 32. This is then possible to configure the running app from the Docker run command, or any compatible Docker environment like: docker run -it -p 8888:80 --rm --name openpaas-videoconference-app -v $PWD .config env: usr share nginx html env linagora openpaas-videoconference-app"
					}

					
				
			
		
			
				
					,
					

					"getting-started-docker": {
						"id": "getting-started-docker",
						"title": "Get started with Docker",
						"category": "",
						"url": " /getting-started/docker/",
						"content": "The easiest way to try OpenPaaS from your local machine is to use Docker Compose. We assume that you already have Git, and Docker Compose, installed on your machine. Run the following commands: # grab the open-paas github repo git clone https: github.com linagora openpaas-esn.git # go to the repo you just cloned cd openpaas-esn # launch it PROVISION=true docker-compose up We set PROVISION=true to create some sample data. You only need it the first time you launch Docker Compose Launching the platform may take some time (1-2 minutes), grab a coffee and when it is ready you can access the application at http: localhost:8080 with username admin@open-paas.org and password secret List of other (non admin) users created: user email address password user1@open-paas.org secret user2@open-paas.org secret user3@open-paas.org secret user4@open-paas.org secret user5@open-paas.org secret user6@open-paas.org secret user7@open-paas.org secret user8@open-paas.org secret user9@open-paas.org secret Discover Some videos to help discover the product: Global presentation (EN) Unified Inbox introduction (FR) Calendar introduction (FR)"
					}

					
				
			
		
			
				
					,
					

					"getting-started-linux": {
						"id": "getting-started-linux",
						"title": "Get started with Linux (deprecated)",
						"category": "",
						"url": " /getting-started/linux/",
						"content": "Important deprecation note Package installation of the OpenPaaS platform is currently deprecated. The current page is kept for informational purpose, but note that it will install the version 1.3 (Oct. 18) of the platform. Table of contents Important deprecation note Setup the target machine Hostname Bootstrap the installation Install packages On Debian Jessie On Debian Stretch On RHEL or CentOS Initialize OpenPaaS Enjoy Discover Global presentation (EN) Unified Inbox introduction (FR) Calendar introduction (FR) Installing OpenPaaS on a Linux server is very easy using provided system packages. This installation method is currently only supported on Debian Jessie and RHEL 7 (or its community companion CentOS 7). Make sure you are starting from a minimal installation for both distributions. The machine should only have standard system utilities (and ssh service). If you just want to try OpenPaaS, check out the Docker guide Setup the target machine Hostname Set the target machine’s hostname using the following command: hostnamectl set-hostname openpaas.local Make sure the hostname is correctly resolved locally using this command: echo \"127.0.0.1 openpaas.local openpaas james.openpaas.local dav.openpaas.local\" | tee -a etc hosts Bootstrap the installation We provide a small bootstrap script to quickly setup the required repositories on the machine you will install OpenPaaS on. To use it, simply run, as root: wget -qO - https: raw.githubusercontent.com linagora openpaas-esn master packaging setup-v1.2.sh | bash or curl -s https: raw.githubusercontent.com linagora openpaas-esn master packaging setup-v1.2.sh | bash depending on the availability of either wget or curl on your system. Install packages Once the bootstrap script has run, you can install the required packages. On Debian Jessie As root: Remove exim apt-get remove -y ^exim* Removing the default mail transfer agent (exim) is required because OpenPaaS comes with a full-featured mail server that also serves as a MTA. Install openjdk-8 apt-get install -t jessie-backports -y openjdk-8-jdk update-alternatives --set java usr lib jvm java-8-openjdk-amd64 jre bin java Install OpenPaaS packages apt-get install -y openpaas openpaas-davserver openpaas-james Enable mongodb service, not enable by default on Jessie : systemctl enable mongod systemctl start mongod To make sure all services are started and enabled on boot, run the following commands as root: systemctl status {mongod,elasticsearch,cassandra,redis-server,rabbitmq-server,nginx,james,openpaas} On Debian Stretch As root: Install OpenPaaS packages apt-get install -y openpaas openpaas-davserver openpaas-james To make sure all services are started and enabled on boot, run the following commands as root: systemctl status {mongodb,elasticsearch,cassandra,redis-server,rabbitmq-server,nginx,james,openpaas} On RHEL or CentOS As root, run: yum erase -y postfix yum install -y openpaas openpaas-davserver openpaas-james Removing the default mail transfer agent (postfix) is required because OpenPaaS comes with a full-featured mail server that also serves as a MTA. To make sure all services are started and enabled on boot, run the following commands as root: systemctl enable {mongod,elasticsearch,cassandra,redis,rabbitmq-server,php-fpm,nginx,james,openpaas} systemctl start {mongod,elasticsearch,cassandra,redis,rabbitmq-server,php-fpm,nginx,james,openpaas} You will also need to configure the firewall to access the different needed ports. For a simple test you can deactivate it: systemctl stop firewalld Initialize OpenPaaS To create a domain and your first administrator, run the following command as the openpaas user or as root: opctl init --email admin@openpaas.local User is created by default as Domain admin. If needed, set your user as Platform Admin (see Platform mode) with the following command: opctl platformadmin init --email admin@openpaas.local The command also provision configurations, hence you need to restart OpenPaaS and James to make these services work properly with the new configurations: systemctl restart {james,openpaas} Enjoy OpenPaaS is installed using the openpaas.local hostname by default, meaning you must access it using this hostname. To do this, add the following line to your etc hosts file (unless you can make openpaas.local resolve to the machine’s IP address using a DNS server): x.x.x.x openpaas.local davserver.openpaas.local james.openpaas.local You can then open a compatible browser to http: openpaas.local and login using admin@openpaas.local with password admin. Discover Some videos to help discover the product: Global presentation (EN) Unified Inbox introduction (FR) Calendar introduction (FR)"
					}

					
				
			
		
			
				
					,
					

					"getting-started-supported-platforms": {
						"id": "getting-started-supported-platforms",
						"title": "Supported platforms",
						"category": "",
						"url": " /getting-started/supported-platforms/",
						"content": "Supported servers We currently support package installation for the following Linux distributions: CentOS RHEL 7 Debian 8 Jessie Supported browsers Mozilla Firefox (Desktop) Mozilla Firefox (Mobile) Google Chrome (Desktop) Google Chrome (Mobile) Apple Safari (Desktop) Apple Safari (Mobile) Microsoft Edge Core modules 52 and up latest 57 and up 57 and up 11 iOS 10 latest * Unified Inbox module 52 and up latest 57 and up 57 and up 11 iOS 10 latest Calendar module 52 and up latest 57 and up 57 and up 11 iOS 10 latest Contact module 52 and up latest 57 and up 57 and up 11 iOS 10 latest Chat module 52 and up latest 57 and up 57 and up No No No Admin module 52 and up latest 57 and up 57 and up 11 iOS 10 latest * The initial page load on Microsoft Edge can take up to one minute."
					}

					
				
			
		
			
				
					,
					

					"modules-admin-configuration-page": {
						"id": "modules-admin-configuration-page",
						"title": "Add a configuration page",
						"category": "",
						"url": " /modules/admin/configuration-page/",
						"content": "Table of contents Overview Build configuration page Register your page Start building your page Template Controller Overview Let’s say you have a configuration used somewhere around OpenPaaS and you want to allow administrator to configure it. Then the best place for having it configurable is a page in Administration module. Build configuration page Register your page First step, you need to define a router state for your page in frontend\\app\\app.routes.js. For example: .state('admin.domain.configpage', { url: ' configpage', views: { 'root@admin': { template: '&lt;admin-configpage &gt;' } } }); Note that, the template must match your corresponding angular component of the page. In order to have an entry of your configuration page displayed in module sidebar, add an object to ADMIN_PAGES constant in frontend\\app\\app.constants.js. For example: { id: 'configpage', name: 'Config Page', icon: 'mdi-library-books', displayIn: { domain: false, platform: true } } id: your page’s id, it needs to match the url linked to your page as you specified in router state name: your configuration page name which is displayed in sidebar icon: a mdi icon that will be shown next to the page name displayIn: decides whether your configuration page is displayed in domain level, platform level or both. Start building your page Create a directory for your own configuration in frontend\\app. Here is where you put all front-end files for your page (component, controller, service, template,…). Template A page in Admin module often composed of two components: subheader, it contains the title and optionally a save button for your configuration form. A component for your entire page, it handles the main logic, configuration form. Depends on the properties of the configuration, there could be more smaller sub-component needed for your page. You are advised to utilize both dumb and smart components. Controller In Admin module, there are already a set of helper services for retrieving and saving configurations. Check frontend app common config admin-domain-config.service.js for the source code. To get your configuration from back-end side: adminDomainConfigService.get(domainId, configName) .then(function(data) { Handle retrieved configuration }); domainId specifies the target domain of your configuration, use as platform for getting platform configuration. configName is the configuration you want to retrieve. To save your configuration: asyncAction({ progressing: 'Saving configuration...', success: 'Configuration saved', failure: 'Failed to save configuration' }, function() { adminDomainConfigService.set(domainId, configName, data); }); Since adminDomainConfigService.set returns a promise. You can use a helper function for this process called asyncAction, where it tracks the status of the promise and pop out a message upon the status, whether the set function failed, succeeded or still running."
					}

					
				
			
		
			
				
					,
					

					"modules-admin-domains": {
						"id": "modules-admin-domains",
						"title": "Domains",
						"category": "",
						"url": " /modules/admin/domains/",
						"content": "Table of contents Overview Creating a domain Editing a domain Fixing error when creating the corresponding domain in James server Overview Domains page is used to manage domains in OpenPaaS. It supports creating and editing domains. Only platform admin can use this feature. Creating a domain Creating a domain also creates its first administrator and corresponding domain in James server. Here are the steps to create a domain: Click floating adding button to show “New domain” form Fill domain name, company name and administrator email password Click on Create or press Enter If success, the domain is added to the list of domains. Editing a domain After creating a domain, platform admin can change its company name. Here are the steps to edit a domain: Click “more actions” button on the domain item to show contextual menu Click on Edit to show “Edit domain” form Change the company name Click on Save or press Enter If success, the domain is updated in the list of domains. Fixing error when creating the corresponding domain in James server There are maybe error when creating the corresponding domain in James server. In that case, domain item has an error indicator at the right side. Platform admin can open contextual menu to see detail of error and try to fix it. Here are the steps to fix error: Click “more actions” button on the domain item to show contextual menu Click on error line (in red) to show fixing error dialog Click on AUTO FIX to try to re-create the domain in James server or click on SETTINGS to see if James settings is correct If error is fixed, the error indicator will be removed."
					}

					
				
			
		
			
				
					,
					

					"modules-admin-elasticsearch": {
						"id": "modules-admin-elasticsearch",
						"title": "Elasticsearch",
						"category": "",
						"url": " /modules/admin/elasticsearch/",
						"content": "Table of contents Overview Setting up Elasticsearch for OpenPaaS Synchronize data in Elasticsearch Upgrade Elasticsearch Overview OpenPaaS integrates Elasticsearch as its search engine. Resources like users, groups, contacts, calendar events, etc, are synchronized between MongoDB database and Elasticsearch so that user can search for resources all around OpenPaaS as fast and accurately as possible. Setting up Elasticsearch for OpenPaaS Make sure you have Elasticsearch up and running on your system under a specific address. On OpenPaaS, naviagate to “Elasticsearch” menu in Platform administration and enter Elasticsearch address, OpenPaaS will then use this address to send search requests to Synchronize data in Elasticsearch To make Elasticsearch works and ensure that the data inside it is always up to date, we need to keep the synchronization between MongoDB database and Elasticsearch. However, sometimes we might lose it due to unexpected reasons such as server running out of storage, Elasticsearch’s outage, etc, or some expected reasons, namely replacing the current Elasticsearch with a higher version. OpenPaaS comes with tools to allow platform administrators to manually update the data mapping to standard mapping and re-synchronize data from OpenPaaS’s MongoDB database to ElasticSearch. These terms are called reindex and re-configure: re-configure: data can be stored incorrectly in Elasticseach which leads to strange search behavior on a resource. This issue is due to a resource having incorrect data mapping configuration. Therefore, platform administrators have the ability to correct the standard data mapping configuration for a resource by using re-configure. reindex: re-synchronize all data from MongoDB to Elasticsearch, this includes re-configure to make sure the standard mapping is used In order to reindex or re-configure data. Under the “Maintenance” page in Platform administration, expanse the “Elasticsearch” section. You can choose to run your desired procedure (“Correct the index configuration (quick)” a.k.a. re-configure or “Correct the index configuration and reindex data (slow)” a.k.a. reindex) on a single type of resource, make sure that your Elasticsearch address is correctly configured. Upgrade Elasticsearch Openpaas ESN 1.5 supports both ElasticSearch version 2.x and 6.x. Starting from OpenPaaS ESN 1.6, it is strictly required to use ElasticSearch 6.x. If you’re using an older version of Elasticsearch and would like to upgrade to use ElasticSearch 6.x for your OpenPaaS instance, you can follow these steps: Make sure Elasticsearch 6.x is up and running on your system under a specific address. On OpenPaaS, navigate to “Elasticsearch” menu in Platform administration and enter Elasticsearch 6.x address. Navigate to “Maintenance” menu, expanse the “Elasticsearch” section and select “Correct the index configuration and reindex data (slow)” on every resource to reindex all data to new Elasticsearch (search result will then be empty until these tasks are done)."
					}

					
				
			
		
			
				
					,
					

					"modules-admin-index": {
						"id": "modules-admin-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/admin/index/",
						"content": "Table of contents Overview Install Features Domain mode Platform mode Overview The linagora.esn.admin module allows domain and platform administrator to configure manage the configuration at the corresponding level. Install You can install admin module by following the OpenPaaS Module installation. Features The module provides configuration interfaces in two modes: domain and platform which corresponding domain and platform permissions. You need have at least one of those permissions to access the module. Once you logged in the OpenPaaS, you can see the Administration item in Application menu And if you have both permissions, you can switch between modes Domain mode If you are a domain administrator, you will see the configuration pages at domain mode. General: Configure the system stuffs like business hours, time format. Features: Enable disable the features in OpenPaaS modules. Mail: Configure mail configuration which will be used to OpenPaaS platform send receive the email with the users. Users: Manage domain members. Roles: Manage domain roles. DAV: Configure DAV server which is required by Calendar and Contact modules LDAP: Configure LDAP configurations which can be used for authentication and attendee provider. Web: Configure the address you want people to type in their browser to reach your OpenPaaS instance. Modules: Each module in OpenPaaS can have its own configuration form allows domain administrator to configure the configuration of those modules. Autoconf: Define the configuration file template used by the autoconfiguration mechanism (for Thunderbird). Theme: Define the theme, logo and favicon of OpenPaas. Platform mode If you are a platform administrator, you will see the configuration pages at platform mode General: Same as the General page in domain mode, plus the ability to change the max login retries. Features: Same as in domain mode. Mail: Same as in domain mode. DAV: Same as in domain mode. Modules: Same as in domain mode. James: Configure James server URL. JWT: Define the algorithm, public-key and private-key that will be used to encode decode JSON web tokens in the ESN instances. Social connections: Configure social connections (Google, Facebook, Github and Twitter). Domain: Manage the domains."
					}

					
				
			
		
			
				
					,
					

					"modules-admin-rest-api": {
						"id": "modules-admin-rest-api",
						"title": "REST API",
						"category": "",
						"url": " /modules/admin/rest-api/",
						"content": "Loading API documentation ..."
					}

					
				
			
		
			
				
					,
					

					"modules-admin-technical-users": {
						"id": "modules-admin-technical-users",
						"title": "Technical users",
						"category": "",
						"url": " /modules/admin/technical-users/",
						"content": "Table of contents Overview Creating a technical user Editing a technical user Removing a technical user Overview Technical users are users having accessibility to data of a domain to perform some technical tasks. For instance, reindexing contacts from MongoDB to Elasticsearch. A default technical user is created by executing the init.js file locating at bin commands when initializing the server. Every technical user belongs to a particular domain. Each domain manages multiple technical users belonged to it. Technical users page is used to manage technical users in OpenPaaS. It supports creating, editing and removing technical users. Currently, only domain admin can use this feature. Creating a technical user A technical user is stored in ESN MongoDB and belongs to a domain where it is created. Here are the steps to create a technical user: Click floating adding button to show “Add a technical user” form Fill name, description, type and data. A new data field can be added by clicking “ADD A NEW DATA FIELD” button. Click on Add If successful, the technical user is added to the list of technical users. Editing a technical user After creating a technical user, the domain admin can modify its name, description, type and data fields. Here are the steps to edit a technical user: Click “more actions” button on the technical user item to show the contextual menu Click on Edit to show “Edit a technical user” form Modify its information Click on Edit If successful, the technical user is updated on the list of technical users. Removing a technical user Here are the steps to remove a technical user: Click “more actions” button on the technical user item to show the contextual menu Click on Remove to show “Remove technical user” form Click Remove to confirm removing that technical user If success, the technical user is removed from the list of technical users. When all of the technical users in a particular domain are removed, some technical tasks for that domain such as reindexing cannot be executed."
					}

					
				
			
		
			
				
					,
					

					"modules-calendar-api": {
						"id": "modules-calendar-api",
						"title": "REST API",
						"category": "",
						"url": " /modules/calendar/api/",
						"content": "Table of contents Introduction Prerequisites CRUD operations Get available calendars Request Response Create a calendar Request List events in calendar Request Create an event in a calendar Request Response Delete an event Request Response Introduction The OpenPaaS calendar API uses jCal specification as defined in the jCal RFC which defines a JSON format for iCalendar. Prerequisites The following samples assumes that you followed the steps to get the cookies used to authenticate user as defined in Authentication documentation In several places in the following REST API samples, parameters will be defined by using {mustache}. Developers will have to replace values by valid ones Standard errors are not listed which does not means that they will not occur (HTTP 4XX and 5XX ones) CRUD operations Get available calendars Request GET https: HOST:PORT dav api calendars {userId}.json Headers accept: application calendar+json Response The response is formatted using Hypertext application Language. Calendar list is available in the _embedded element as dav:calendar array. The href value is the calendar URL which can be used to do operations on the calendar. As of 170503 and reported in CAL-670, the href links are not well formatted. Body 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 { \"_links\":{ \"self\":{ \"href\":\" sdav calendars 57fca675a91c8d01a36ac26b.json\" } }, \"_embedded\":{ \"dav:calendar\":[ { \"_links\":{ \"self\":{ \"href\":\" sdav calendars 57fca675a91c8d01a36ac26b events.json\" } }, \"calendarserver:ctag\":\"http: sabre.io ns sync 101\" }, { \"_links\":{ \"self\":{ \"href\":\" sdav calendars 57fca675a91c8d01a36ac26b aee302d8-12dc-4c8d-94cf-991da9b453ab.json\" } }, \"dav:name\":\"My public calendar\", \"caldav:description\":\"\", \"calendarserver:ctag\":\"http: sabre.io ns sync 7\", \"apple:color\":\"#f7e511\" } ] } } Create a calendar Request The {userId} is the id of the authenticated user. POST https: HOST:PORT dav api calendars {userId}.json Body 1 2 3 4 5 6 { \"id\": \"ebdfe2b9-694a-4dc3-98fa-0f7acbfdc739\", \"dav:name\": \"My calendar name\", \"apple:color\": \"#68c289\", \"caldav:description\": \"The calendar description\" } List events in calendar Request REPORT https: openpaas.linagora.com dav api calendars 57fca675a91c8d01a36ac26b events.json' Body 1 2 3 4 5 6 { \"match\": { \"start\": \"20170430T000000\", \"end\": \"20170613T000000\" } }' Create an event in a calendar In order to create an event, the user must send the new event as jCal in an existing calendar (the list of calendars and their URL can be found as described above). Request The {eventId} is defined by the developer. We suggest to use an uuid generator to have unique ids. PUT https: HOST:PORT dav api calendars {userId} {calendarId} {eventId}.ics Body 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 [ \"vcalendar\", [], [ [ \"vevent\", [ [ \"uid\", {}, \"text\", \"0d52de98-127c-4625-8583-57ec07e9bfd9\" ], [ \"transp\", {}, \"text\", \"OPAQUE\" ], [ \"dtstart\", { \"tzid\":\"Europe Berlin\" }, \"date-time\", \"2017-05-03T16:00:00\" ], [ \"dtend\", { \"tzid\":\"Europe Berlin\" }, \"date-time\", \"2017-05-03T17:00:00\" ], [ \"organizer\", { \"cn\":\"Christophe HAMERLING\" }, \"cal-address\", \"mailto:chamerling@linagora.com\" ], [ \"class\", {}, \"text\", \"PUBLIC\" ], [ \"summary\", {}, \"text\", \"Barcamp doc test\" ], [ \"location\", {}, \"text\", \"Paris\" ], [ \"description\", {}, \"text\", \"Blahblah\" ], [ \"attendee\", { \"partstat\":\"NEEDS-ACTION\", \"rsvp\":\"TRUE\", \"role\":\"REQ-PARTICIPANT\", \"cn\":\"Michael BAILLY\" }, \"cal-address\", \"mailto:mbailly@linagora.com\" ], [ \"attendee\", { \"partstat\":\"ACCEPTED\", \"rsvp\":\"FALSE\", \"role\":\"CHAIR\" }, \"cal-address\", \"mailto:chamerling@linagora.com\" ] ] ] ] ] Response {\"id\":\"491cd007-3646-4fe2-93a5-7a8281e9e36d\"} Delete an event Request DELETE https: HOST:PORT dav api calendars {userId} {calendarId} {eventId}.ics Response Body {\"id\":\"491cd007-3646-4fe2-93a5-7a8281e9e36d\"}"
					}

					
				
			
		
			
				
					,
					

					"modules-calendar-index": {
						"id": "modules-calendar-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/calendar/index/",
						"content": "Table of contents Overview Install OpenPaaS Module Sabre Server Features Overview The calendar module brings powerful and realtime calendar support into the OpenPaaS platform. It is composed of several components: A frontend component. Built using Angular. A backend component which can be split into two parts: A DAV compliant backend built on top of Sabre A specific backend, built using Node.js, which mainly listen to specific technical events and so provides realtime support and data indexing. Install OpenPaaS Module If the calendar module is not provided with the OpenPaaS distribution, you can install it by following the installation instructions in the calendar repository. Sabre Server The calendar module needs a Sabre server to run. Thanks to its plugin system, the default Sabre distribution has been extended to provide more advanced features. Installation instructions can be found in the esn-sabre repository. Features The calendar module provides standard calendar features: CalDAV support Event creation edition deletion Attendees with accept decline … Recurrent events Alarms email notifications Calendar delegation Public calendars and subscriptions and more advanced ones: Calendar resources Full text search Realtime synchronization between browsers VideoConference link"
					}

					
				
			
		
			
				
					,
					

					"modules-calendar-resource": {
						"id": "modules-calendar-resource",
						"title": "Calendar Resources",
						"category": "",
						"url": " /modules/calendar/resource/",
						"content": "Table of contents Overview Requirements Creating a calendar resource Booking a resource from an event Overview OpenPaaS users can book physical resources from the Calendar module: Meeting room, car, projector or any other resource people might schedule a time to use. This chapter describes the steps used to implement resource support in the calendar module. Note: Resource is a general concept provided and managed in the linagora.esn.resource module. Requirements A resource can be booked by adding it as attendee in an event Adding a resource as attendee to an event follows the same process as adding an user as attendee to an event There is are managers to accept or decline the event in the resource calendar: The event is automatically accepted ie the resource is booked Calendar resources have their own calendar in the CalDAV server. When a resource is booked, an event is added to the resource calendar. Creating a calendar resource Until a page is provided to create resources, they can be created from the resource REST API: Request POST linagora.esn.resource api resources { name: 'Meeting Room 1' description: 'The big meeting room at the first floor', type: 'calendar' } Response HTTP 201 - Created { \"__v\": 0, \"_id\": \"59cba12b35cb3e03c3148dac\", \"name\": \"Meeting Room 1\", \"description\": \"The big meeting room at the first floor\", \"type\": \"calendar\", \"creator\": \"599da2a9b7cd7d161eaad48d\", \"domain\": \"599da2a5b7cd7d161eaad487\", \"timestamps\": { \"creation\": \"2017-09-27T13:01:31.732Z\" } } Where: _id is the resource id creator is the id of the user who created the resource domain is the domain the resource belongs to. By default, it is set to the domain the user was connected when he created the resource The calendar module will then create the related resource calendar like this: Once a resource is created, it is published on the resource:created local topic. The calendar module listens to the resource:created topic. If the resource received has a valid type value (calendar), it creates a new calendar for the resource by calling the CalDAV server Calendar is available in the CalDAV server under the resources ${_id} calendars events.json path. Booking a resource from an event For now, in oder to book a resource, it has to be added as attendee to an event as other users. From the UI point of view, this is exactly the same as adding any other user to the event: Searching for the resource in the attendee search field and add it by clicking on the suggestion. On the ICS point of view, a resource is translated as an attendee with specific values: ATTENDEE;CN=\"Meeting Room 1\";CUTYPE=RESOURCE;PARTSTAT=ACCEPTED;MAILTO:id@openpaas-domain.org Where CN (Common Name) is generated from the resource name CUTYPE (Calendar User Type) is set to RESOURCE PARTSTAT is automatically set as ACCEPTED MAILTO is set to a generated email address with the resource._id as email local-part and the domain name the resource belongs to as email domain When the CalDAV backend will receive the event ICS, it will extract attendees, and for the ones with CUTYPE=RESOURCE, it will retrieve the resource calendar from the mailtolocal-part, then create the event."
					}

					
				
			
		
			
				
					,
					

					"modules-calendar-shared": {
						"id": "modules-calendar-shared",
						"title": "Shared Calendars",
						"category": "",
						"url": " /modules/calendar/shared/",
						"content": "Table of contents Overview Public calendars Delegated calendars Technical considerations Overview The calendar module supports two kinds of shared calendars: Delegated calendars: when an owner delegates his own calendars to other users. For example, a manager can delegate his calendars to his secretary. Public calendars: an owner can set his calendars to public. Other users, or external ones, can subscribe to such calendars and see events. There are some differences between these types of shared calendars, the main ones are: Delegated calendars represent a privileged access for a given calendar to a specific user. Public calendars can be seen by everyone, and any user can add them. In some cases, any users are also abe to create events in public calendars. Shared calendars come with rights: Rights are applied to users who are looking at other users calendars. Free Busy: User can only see that the calendar owner is free or busy in a timeperiod. The details of the events are not available. Read: User has access to all the event informations but can not change anything. Write: User has access to all the event informations and can change anything. Administration: User can do anything on the calendar (edit, delete, etc) as well as on the calendar events. Public calendars In order make a calendar public, the user has to change the Public right to Free Busy, Read or Write during the calendar creation, or on the calendar settings page as shown below. Once a calendar is public, other users can subscribe to it by going to the Shared Calendars page and by doing a search. Public calendars are linked to their creator, so in order to find them, the user has to search for the creator to find all his public calendars. In the screenshot below, one public calendar is displayed. In order to subscribe to this public calendar, the user has to click on the Add toggle button then on Save. The calendar is now displayed as a Shared calendar. The user can see events and create some if Write rights are set on the public calendar. Delegated calendars A user can delegate his calendar by adding users in the delegation section in the calendar settings pages. A user which is added is called a Sharee. In order to add a user as sharee: Search for user, once found, click on it Set the right level Click on Add The user is added to the list of Sharee Once the calendar is saved, it is “ready to be delegated”: The sharee can not do anything until he adds the delegated calendar to his calendars. This is possible by going to the Shared calendars page and by doing a search just like for public calendars. In the screenshot below, one delegated calendar is displayed. In order to add this delegated calendar, the sharee has to click on the Add toggle button then on Save. The calendar is now displayed as a Shared calendar. The sharee can see events and create some if Write or Administration rights are set on the calendar. Technical considerations When a user has a delegated calendar, a new instance of the given calendar is created for him on the backend side. When a user add a public calendar, the backend will create a subscription for this calendar. A subscription is an object owned by the user and stored in the backend. This object has a reference towards the public calendar along with its own properties."
					}

					
				
			
		
			
				
					,
					

					"modules-community-index": {
						"id": "modules-community-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/community/index/",
						"content": "The community module allows to create groups of interests and to launch discussions, share documents, like, etc. Features The community module provides the following features: Create public private restricted communities with the capability to invite users to join or to add them as member. Create rich messages, rich replies: A message can be composed of a text, several attachments (photos, videos, any file), user location, etc… Create polls Like messages resources Share messages in other communities Reply to messages by email API The API is described in Community API documentation."
					}

					
				
			
		
			
				
					,
					

					"modules-contact-collected": {
						"id": "modules-contact-collected",
						"title": "Collected contacts",
						"category": "",
						"url": " /modules/contact/collected/",
						"content": "Table of contents Overview Install Collector engine Calendar collector source API Messages Message with userId Message with userEmail Overview OpenPaaS provides a contact collector feature which goal is to automatically create contacts from several sources without any user interaction. These collected contacts are then available in a specific user addressbook called collected and available in the contact module as other contacts. Current collector sources are: Calendar module: When an event is created in a calendar, the event attendees are collected. James Mail Server (Under development): When an email is sent, recipients are collected. Install Collector engine The engine in charge of listening to collector sources and of creating contacts is provided by the linagora.esn.contact.collect module. It is installed by default in the OpenPaaS distribution. Repository: https: ci.linagora.com linagora lgs openpaas linagora.esn.contact.collect.git Calendar collector source The source in charge of listening to calendar events create update and publishing into the collector engine is provided by the linagora.esn.calendar.collect.email. It is installed by default in the OpenPaaS distribution. Repository: https: ci.linagora.com linagora lgs openpaas linagora.esn.calendar.collect.email.git API The contact collector module listens to events on the collector:email exchanges on the OpenPaaS AMQP provider (RabbitMQ). Once a message is received, it is processed to add new emails as contacts in a specific CardDAV addressbook (collected address book) of the current user. Messages Message content to be published on collector:email AMQP exchange must follow the following rules: Message payload is a JSON as String. Message must contain the userId or the userEmail which will be used to identify the OpenPaaS user to collect contacts for. Message must contain an array of emails. Message with userId OpenPaaS user will be found using the given userId. { \"userId\": \"57fca675a91c8d01a36ac26b\", \"emails\": [\"user1@open-paas.org\", \"User2 &lt;user2@open-paas.org&gt;\", \"John Doe &lt;john.doe@open-paas.org&gt;\", \"user3@open-paas.org\"] } Message with userEmail OpenPaaS user will be found using the given userEmail. { \"userEmail\": \"admin@open-paas.org\", \"emails\": [\"user1@open-paas.org\", \"User2 &lt;user2@open-paas.org&gt;\", \"John Doe &lt;john.doe@open-paas.org&gt;\", \"user3@open-paas.org\"] }"
					}

					
				
			
		
			
				
					,
					

					"modules-contact-domain-address-book": {
						"id": "modules-contact-domain-address-book",
						"title": "Domain address book",
						"category": "",
						"url": " /modules/contact/domain-address-book/",
						"content": "Table of contents Overview Management Enable Disable Role of members Overview Domain address book contains contacts, which is shared among members of single domain. Domain administrator can enable or disable the address book. By default, domain members can see all the contacts. Domain members can get more access such as: add, edit, delele the contacts or share rights of the address book to other members when they are delegated by an address book’s administrator. Management Enable Only domain administrator can enable domain address book feature on modules admin page. Enabling the address book will make it visible in Contacts page of all domain users, the address book will be put in Domain address book section of sidebar. Disable Only domain administrator can disable domain address book feature on modules admin page. Disabling will hide the address book and its contacts to all domain users. All the contacts and configurations are preserved. Role of members Domain address book is an address book. Therefore, the address book inherit features of a common address book such as: Public right and Deligate. Adminstrator of the domain address book is the domain member has rights to read, write and share (public and delegate) the address book. Read how to use shared address book. Because the contacts in the address book are shared resources. The data should be trusted for using by other domain members. Adminstrators need to consider before sharing rights to a certain user."
					}

					
				
			
		
			
				
					,
					

					"modules-contact-domain-members-address-book": {
						"id": "modules-contact-domain-members-address-book",
						"title": "Domain members address book",
						"category": "",
						"url": " /modules/contact/domain-members-address-book/",
						"content": "Table of contents Overview Management Enable Domain scope Platform scope Disable Domain scope Platform scope Synchronize Domain scope Platform scope Overview Domain members address book (DMAB) is an address book of a domain and contains mapping contacts from all active domain members. An active domain members can login and can be searched on OpenPaaS Domain administrators can enable, disable and synchronize the address book. Platform administrators can also manage the address books for all domains which do not configure DMAB yet. One of the most useful cases is when initializing the system, the platform administrator can manage the address book for all domains. Management Enable Domain scope Domain administrators can enable DMAB feature. The following actions will be done: Turn on the feature flag of domain. Create an address book named domain-members if it does not exist. Create mapping contacts from domain members into the DMAB. Result: The address book will be put in Domain members section of sidebar in Contacts page. All active domain member contacts are also displayed. Platform scope Platform administrators can enable DMAB feature for domains of platform that has not configured DMAB yet. Below are steps: Turn on the feature flag of platform. Synchronize each single domain of platform. See synchronize a DMAB. Result: On a domain that has not configured DMAB yet, the address book will be put in Domain members section of sidebar in Contacts page. On a domain has its own DMAB’s configuration, the display of Domain members section depends on DMAB’s domain configuration. Disable Domain scope Domain administrators can disable DMAB feature. The following actions will be done: Turn off the feature flag of domain. Delete the address book. Result: On success, the address book of the domain will be deleted. Domain members can’t see Domain members section of sidebar in Contacts page. Platform scope Platform administrators can disable DMAB feature for domains of platform that do not configured DMAB yet. Below are steps: Turn off the feature flag of platform. Synchronize each single domain of platform. See synchronize a DMAB. Result: On a domain that has not configured DMAB yet, domain members can’t see Domain members section of sidebar in Contacts page. On a domain has its own DMAB’s configuration, the display of Domain members section depends on DMAB’s domain configuration. Synchronize Synchronization allows domain or platform administrators to synchronize DMAB. There are 2 scenarios: The feature is disabled: For some reasons, Sabre service is stopped when disabling the feature at ESN side, so the address book still there in Sabre. Synchronization will remove this address book. The feature is enabled: Domain members can be added, updated and blocked. So we need to refresh mapping contacts in DMAB by adding, updating and removing them. Domain scope Synchronizing DMAB action will get all active users at that time to create new set of domain member contacts Result: On success, domain members contacts in Contacts page will be updated. Platform scope Platform administrators can synchronize DMAB for all domains that do not configure DMAB feature yet. Result: On a domain that has not configured DMAB yet, domain members contacts in Contacts page will be updated. On a domain has its own DMAB’s configuration, the display of Domain members section and contacts depends on DMAB’s domain configuration."
					}

					
				
			
		
			
				
					,
					

					"modules-contact-index": {
						"id": "modules-contact-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/contact/index/",
						"content": "Table of contents Overview Install OpenPaaS Module Sabre Server Features Overview The contact module brings powerful and realtime contact support into the OpenPaaS platform. It is composed of several components: A frontend component. Built using Angular. A backend component which can be split into two parts: A DAV compliant backend built on top of Sabre A specific backend, built using Node.js, which mainly listen to specific technical events and so provides realtime support and data indexing. Install OpenPaaS Module The contact module is provided in the OpenPaaS modules directory and enabled by default. Sabre Server The calendar module needs a Sabre server to run. Thanks to its plugin system, the default Sabre distribution has been extended to provide more advanced features. Installation instructions can be found in the esn-sabre repository. Features The contact module provides standard features: CardDAV support Contact creation edition deletion and more advanced ones: Full text search Realtime synchronization between browsers Social networks contact import and synchronization Collected contacts Shared address books Domain address book Domain members address book"
					}

					
				
			
		
			
				
					,
					

					"modules-contact-shared": {
						"id": "modules-contact-shared",
						"title": "Shared Address Books",
						"category": "",
						"url": " /modules/contact/shared/",
						"content": "Table of contents Overview Public address books Delegated address books Technical considerations Overview The Contact module supports two kinds of shared address books: Public address books: an owner can set his address books to public. Other users in the same domain can subscribe to such address books. Delegated address books: an owner can delegate his own address books to other users in the same domain. There are some differences between these types of shared address books, the main ones are: Public address books can be seen by everyone, and any user can subscribe to them. Delegated address books represent a privileged access for a given address book to a specific users. Shared address books come with rights: Rights are applied to users who are looking at other users address books. Read: User has access to all the contact information but can not change anything. Write: User has access to all the contact information and can update delete contacts. Administration: User not only has read write rights but also can share (public and delegate) address books. Public address books In order to make an address book public, the user has to change the Public right to Read or Write on the address book settings page as shown below. Once an address book is public, other users can subscribe to it by searching for owners’ name in Shared address book dialog. Public address books are linked to their creator, so in order to find them, the user has to search for the creator to find all his public address books. In order to subscribe to this public address book, the user has to click on the Add toggle button then on Save. The address books is now displayed as a Shared address book. The user can see contacts and create some if Write rights are set on the public address book. Delegated address books A user can delegate his address books to others by adding them to Delegation list. A user who is added called a sharee. In order to add a sharee: Go to address book Setting page, switch to Delegation tab Search for user Set the right level for selected user Click Add to add the user in to delegation list Click Save in sub header to save the delegation list Once the address book is saved, it is “ready to be delegated”: The sharee can not do anything until he subscribes the delegated address book. This is possible by going to the Shared address books page then do a search just like for public address books. In the screenshot below, one delegated address book is displayed. In order to add this delegated address book, the sharee has to click on the Add toggle button then on Save. The address book is now displayed as a Shared address book, the sharee can see contacts as default. He can create, edit or remove contacts if Write or Administration rights are set to him. If Administration rights is set, the sharee can delegate the address book. Technical considerations When a user add a public address book, the backend will create a subscription for this address book. A subscription is an object owned by the user and stored in the backend. This object has a reference towards the public address book along with its own properties. When a user has a delegated address book, a new instance of the given address book is created for him on the backend side."
					}

					
				
			
		
			
				
					,
					

					"modules-group-index": {
						"id": "modules-group-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/group/index/",
						"content": "Table of contents Overview Overview OpenPaaS module for group feature"
					}

					
				
			
		
			
				
					,
					

					"modules-group-rest-api": {
						"id": "modules-group-rest-api",
						"title": "REST API",
						"category": "",
						"url": " /modules/group/rest-api/",
						"content": "Loading API documentation ..."
					}

					
				
			
		
			
				
					,
					

					"modules-howto-deep-dive": {
						"id": "modules-howto-deep-dive",
						"title": "Deep dive",
						"category": "",
						"url": " /modules/howto/deep-dive/",
						"content": "Table of contents Minimal Module Add backend API Expose a library Expose Angular module Add CSS Rules Minimal Module The most simple OpenPaaS module got a name, and returns an instance of the AwesomeModule object. The module name is free, although, by convention, we use the dot separator, going to generic to specific. For example: linagora.esn.unifiedinbox.twitter The linagora.esn prefix is used by the core team, so please don’t use it, or ask us ! (we’re gentlemen, don’t worry). The module files should be in a folder that have the exact name of the module. That is how the module loader finds the modules. Example of a minimal OpenPaaS module : com.example.module index.js: 1 2 3 4 const AwesomeModule = require('awesome-module'); const esnModule = new AwesomeModule('com.example.module', {}); module.exports = esnModule; Needless to say that this module does absolutely nothing. Add backend API One thing you’ll certainly have to do when developing on the OpenPaaS platform, is to add some backend endpoint. To achieve that, we use the Express framework, and more precisely the Router. You then use the WebServer Wrapper module to add your routes into the platform web server. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const AwesomeModule = require('awesome-module'); const Dependency = AwesomeModule.AwesomeModuleDependency; const esnModuleRouter = require('. backend router'); const esnModule = new AwesomeModule('com.example.module', { dependencies: [ new Dependency(Dependency.TYPE_NAME, 'linagora.esn.core.webserver.wrapper', 'webserver-wrapper') ], states: { deploy: deploy } }); function deploy(dependencies, callback) { const webserver = dependencies('webserver-wrapper'); webserver.addApp('example', esnModuleRouter(dependencies)); callback(); } module.exports = esnModule; Now let’s dig into that piece of code, we’ll comment the most important lines. On line 7, we ask the OpenPaaS module system to inject the webserver wrapper module (whose full name is “linagora.esn.core.webserver.wrapper”). We also tell it to expose it with the label “webserver-wrapper”, which means that, when we need to acces that module, we use the dependencies('webserver-wrapper') call. We add on line 10 the declaration of the deploy state for our module. All OpenPaaS modules states are declared using functions, taking two arguments, the dependencies function allowing your module to access the dependencies it previously asked for, and a callback function, which is a node-style callback, meaning that the first argument of that function should be an error (if any). Now let’s see what we do in the deploy state. We get the webserver wrapper module library on line 15, and assign it to the webserver variable. Now, and it’s the important part of the stuff, we call on line 16 the addApp method exposed by the webserver module library. This method takes two arguments: a string representing the URI namespace of your module, and an express Router. addApp(String, Router) That basically means, that our module API will expose all its endpoints after the “ example ” URL path. We’ll get back at it just after having described a first API route. Finally, on line 17, we launch the callback method, telling the OpenPaaS module framework that our module has finished transitioning to the deploy state, without any trouble. Should we have encountered a problem, we’d have called the callback with an error as the first argument, for example: callback(new Error('Something wrong happened here')); On line 3, we include a local file . backend router, here is an example content of that file: 1 2 3 4 5 6 7 8 9 10 11 12 13 const express = require('express'); module.exports = esnModuleRouter; function esnModuleRouter(dependencies) { const router = express.Router(); router.get(' api', function(req, res) { res.status(200).json({ok: true}); }); return router; } Meaning, we declare a endpoint on the api URI. But, if you remember well, we used the OpenPaaS addApp(‘example’, ourRouter) method to include our routes in the global OpenPaaS web server. Provided that our root URL is https: localhost , then our module endpoint will be reachable at the URL https: localhost example api. Expose a library OpenPaaS modules can expose libraries to other modules. Libraries allow other modules to use the features you provide. For example, a user module may expose a get() and a create() method. Let’s expose some dumb library for the sake of the tutorial. First of all, we’ll create the library that we’ll return. We create the file backend lib.js file in our module folder, with the following content: 1 2 3 4 5 6 7 8 9 10 11 function exampleLib(dependencies) { const library = { get: function() { return 'Hey, I am an example'; } }; return library; } module.exports = exampleLib; Our library exposes a get() method, that returns an example, which is, for now, a String. Now, we’ll instruct the OpenPaaS module framework that we export this library. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const AwesomeModule = require('awesome-module'); const exampleLib = require('. backend lib'); const esnModule = new AwesomeModule('com.example.module', { states: { lib: lib } }); function lib(dependencies, callback) { const library = exampleLib(dependencies); callback(null, library); } module.exports = esnModule; On line 2, we include our local library file. On line 6, we tell the OpenPaaS module system that we are now using the lib state to declare a library for other modules to use. On line 10, we create the said lib function, in which we instanciate our library (line 11). Finally, on line 13, we launch the module system’s callback, passing it the library (as the second argument, the first one being an error if any). Now, any module that injects our module will benefit our awesome library. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const AwesomeModule = require('awesome-module'); const Dependency = AwesomeModule.AwesomeModuleDependency; const esnModule = new AwesomeModule('com.example.module2', { dependencies: [ new Dependency(Dependency.TYPE_NAME, 'com.example.module', 'example-module') ], states: { lib: function(dependencies, callback) { const exampleModule = dependencies('example-module'); console.log(exampleModule.get()); Hey, I am an example } } }); module.exports = esnModule; Q. How can I access my own library in the other states of my module ? A. The library is exposed as the this variable in the other state declaration functions. Let’s take back our module to get an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const AwesomeModule = require('awesome-module'); const exampleLib = require('. backend lib'); const esnModule = new AwesomeModule('com.example.module', { states: { lib: lib, deploy: deploy } }); function lib(dependencies, callback) { const library = exampleLib(dependencies); callback(null, library); } function deploy(dependencies, callback) { console.log(this.get()); Hey, I am an example } module.exports = esnModule; On line 18, we use our library “get()” method. As said before, our library is exposed as the this variable in the deploy function. Q. I did what you told me, but this is an empty object and not my exported lib. Why is that ? A. We guess you used the new ES6 arrow functions to declare your deploy state. With arrow functions, the “this” object is lexically bound to the function. So, in your code, replace: { deploy: (dependencies, callback) =&gt; { this.get(); } } with: { deploy: function (dependencies, callback) { this.get(); } } and it should work as expected. Expose Angular module The OpenPaaS frontend relies heavily on AngularJS. The OpenPaaS module framework provides a way to let you add your JavaScript files in the frontend page (so it will add the &lt;script&gt; tags for you). Moreover, it will also add into the main OpenPaaS Angular module the dependencies to your provided modules. This is a two-steps process. First, you should add to your Express router the ability to serve your JavaScript files. Second, you should tell OpenPaaS, the files that should be included, for a specific OpenPaaS application. Serve your JavaScript files Let’s say that your Angular code is composed of two files. An app.js file, and a controller.js file. Here is the content of your app.js file: 1 2 3 (function() { angular.module('com.example.module.angular', []); })(); And the content of your controller.js : 1 2 3 4 5 6 7 8 9 10 (function() { angular.module('com.example.module.angular') .controller('exampleModuleController', ExampleModuleController); function ExampleModuleController() { this.sayHello = function() { console.log('Hello'); }; } })(); Now, put those two files in the frontend app folder of your module. Open the file backend router.js and put the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 const express = require('express'); const resolve = require('path').resolve; const FRONTEND_PATH = resolve(__dirname, '.. frontend'); module.exports = esnModuleRouter; function esnModuleRouter(dependencies) { const router = express.Router(); router.use(express.static(FRONTEND_PATH)); return router; } What we just did here is to create a new router just like we did in the backend API chapter. Next, in the deploy state, we register our router : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const AwesomeModule = require('awesome-module'); const Dependency = AwesomeModule.AwesomeModuleDependency; const esnModuleRouter = require('. backend router'); const esnModule = new AwesomeModule('com.example.module', { dependencies: [ new Dependency(Dependency.TYPE_NAME, 'linagora.esn.core.webserver.wrapper', 'webserver-wrapper') ], states: { deploy: deploy } }); function deploy(dependencies, callback) { const webserver = dependencies('webserver-wrapper'); webserver.addApp('example', esnModuleRouter(dependencies)); callback(); } module.exports = esnModule; Now you can check that when pointing your browser to https: localhost:8080 example app app.js , you got your JavaScript file served. We’ll now tell the OpenPaaS system that it should add those JavaScript files and the Angular module dependency in the frontend file. To be able to do this, we have to know on what OpenPaaS application we want our Angular files to be injected. Right now, there are two OpenPaaS applications available: welcome This is the login page esn This is the main application, that you access to when you are logged in Let’s say our Angular files should be in the esn application. We’ll update our deploy state: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const glob = require('glob-all'); const resolve = require('path').resolve; const AwesomeModule = require('awesome-module'); const Dependency = AwesomeModule.AwesomeModuleDependency; const esnModuleRouter = require('. backend router'); const FRONTEND_PATH = resolve(__dirname, 'frontend'); const esnModule = new AwesomeModule('com.example.module', { dependencies: [ new Dependency(Dependency.TYPE_NAME, 'linagora.esn.core.webserver.wrapper', 'webserver-wrapper') ], states: { deploy: deploy } }); function deploy(dependencies, callback) { const webserver = dependencies('webserver-wrapper'); webserver.addApp('example', esnModuleRouter(dependencies)); const frontendModulesFiles = glob.sync([ FRONTEND_PATH + ' ** *.js' ]); const frontendRelPathFiles = frontendModulesFiles.map(f =&gt; f.replace(FRONTEND_PATH, '')); webserver.injectAngularAppModules('example', frontendRelPathFiles, ['com.example.module.angular'], ['esn']); callback(); } module.exports = esnModule; Let’s detail what we just did here. On lines 22 to 25, we extract the list of JavaScript files that we put in the frontend folder. We use the awesome glob-all library for this, but you can as well list files manually in an array. Then, on line 27 we call the injectAngularAppModules() function, that takes the following arguments: webserver.injectAngularAppModules(String namespace, [String] javascript files URI, [String] Angular module names, [String] OpenPaaS application); String namespace The namespace under which you files are served. It should be the same as the namespace that you set in the addApp() method. [String] javascript files URI An array of the list of all files that are being included by the browser in the Rich Internet Application [String] Angular module names An array of the names of Angular modules that our OpenPaaS modules is exposing [String] OpenPaaS application An array of the OpenPaaS applications that should include your module files and Angular modules. Optimization You can have the OpenPaaS platform optimize for you your JavaScript files, by concatening them and serving one big file instead of several little files. To do that, you have to tell the framework the whole path to your JavaScript files. Here is the updated deploy function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function deploy(dependencies, callback) { const webserver = dependencies('webserver-wrapper'); webserver.addApp('example', esnModuleRouter(dependencies)); const frontendModulesFiles = glob.sync([ FRONTEND_PATH + ' ** *.js' ]); const frontendRelPathFiles = frontendModulesFiles.map(f =&gt; f.replace(FRONTEND_PATH, '')); webserver.injectAngularAppModules('example', frontendRelPathFiles, ['com.example.module.angular'], ['esn'], { localJsFiles: frontendModulesFiles }); callback(); } module.exports = esnModule; We added an options hash to the injectAngularAppModules() method. It contains a localJsFiles property, whose value is the list of JavaScript file for your application. Add CSS Rules The OpenPaaS framework comes bundled with a lot of CSS classes already defined, thanks to our underlying Material Admin framework. However, you’ll maybe have to add your own CSS rules alongisde your JavaScript files and HTML templates. We use LESS CSS pre-processor. All you have to do is to create a less file, it will inherit all the already defined less rules. Moreover, you’ll be able to override less variables, if you need to. Here is how to append your less rules to the framework: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const resolve = require('path').resolve; const AwesomeModule = require('awesome-module'); const Dependency = AwesomeModule.AwesomeModuleDependency; const esnModule = new AwesomeModule('com.example.module', { dependencies: [ new Dependency(Dependency.TYPE_NAME, 'linagora.esn.core.webserver.wrapper', 'webserver-wrapper') ], states: { deploy: deploy } }); function deploy(dependencies, callback) { const webserver = dependencies('webserver-wrapper'); const myLessFile = resolve(__dirname, 'frontend style.less'); webserver.injectLess('example', [myLessFile], ['esn']); callback(); } module.exports = esnModule; On line 16, we find the absolute path to our less file. On line 18, we use the framework’s injectLess() method to register our less file to the list of files that should be compiled and then served to the browser. The injectLess method got the following signature: webserver.injectLess(String namespace, [String] less files absolute path, [String] OpenPaaS application); String namespace The namespace under which you files are served. It should be the same as the namespace that you set in the addApp() method. [String] less files absolute path An array of the list of all less files that we want to include into the compiled CSS file that will be sent to the server. [String] OpenPaaS application An array of the OpenPaaS applications that should include your module files and Angular modules."
					}

					
				
			
		
			
				
					,
					

					"modules-howto-electron-compatibility": {
						"id": "modules-howto-electron-compatibility",
						"title": "How to be Electron compatible",
						"category": "",
						"url": " /modules/howto/electron-compatibility/",
						"content": "OpenPaaS uses ElectronJS to provide the users a desktop client. Modules should follow some rules to be able to work using Electron. URL prefixing When serving the application from a server, there is obviously real problem on what is the server… On the contrary, on a desktop application, the application should know the URL of the server. OpenPaaS supports different ways of doing so. Make your Restangular instances managed Most of the server calls are run through Restangular. We provide a system to make a module’s restangular instance aware of the server URL. Here is the code before : angular.module('great.module') .factory('greatModuleAPI', function(Restangular) { return Restangular.withConfig(function(RestangularConfigurer) { RestangularConfigurer.setBaseUrl(' great api'); RestangularConfigurer.setFullResponse(true); }); }); The module have to use the manageRestangular method of the httpConfigurer service. Here is the Electron compatible code: angular.module('great.module') .factory('greatModuleAPI', function(Restangular, httpConfigurer) { var restangularInstance = Restangular.withConfig(function(RestangularConfigurer) { RestangularConfigurer.setFullResponse(true); }); I tell httpConfigurer to manage the base URL of my restangular instance httpConfigurer.manageRestangular(restangularInstance, ' great api'); return restangularInstance; }); We can see two main differences between the code before and after: we don’t use the native restangular.setBaseUrl() method anymore we call httpConfigurer.manageRestangular() with the module’s restangular instance, and the base URI of the module (which is the same we used to set using RestangularConfigurer.setBaseUrl(…)). Fix your $http (and other) calls For a vast variety of reasons, modules may not use Restangular. In that case, the httpConfigurer service provides a nifty getUrl() method to help the developer setting the right final URL. Here is the code before: angular.module('great.module') .factory('generateJwtToken', function($http) { return function() { return $http.post(' api jwt generate'); }; }); and the code after: angular.module('great.module') .factory('generateJwtToken', function($http, httpConfigurer) { return function() { return $http.post(httpConfigurer.getUrl(' api jwt generate')); }; }); Here, we only return the result of httpConfigurer.getUrl() instead of directly setting the URI."
					}

					
				
			
		
			
				
					,
					

					"modules-howto-index": {
						"id": "modules-howto-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/howto/index/",
						"content": "Table of contents Overview Modules dependencies Modules lifecycle lib deploy start Overview OpenPaaS modules (also called AwesomeModules) come on top of classic NPM modules, to provide an enterprise grade module system. The main improvements over the classic Node NPM system are: OpenPaaS modules brings dependencies, either by name, or by ability OpenPaaS modules supports asynchronous loading OpenPaaS modules got a lifecycle, and go through states during their initialization Modules dependencies OpenPaaS modules dependencies express, as we can expect, dependencies between modules. This dependency can be either by name, just like NPM, where you say “I’m dependant of the module example-logger version 2.0.0”, and also by ability : so you can say “I’m dependant of the logger ability”, and any module exposing this ability can be used. OpenPaaS modules use the well known dependency injection pattern, usefull to build extensible, and testable, systems. Modules lifecycle During the startup of the NodeJS server, the modules are loaded. OpenPaaS provides three states. All states are optional: you don’t have to code them if you don’t need them. lib This is the first step. Upon this step, your module should send back its library, that dependant modules (the modules that requires yours) will receive when they inject it. For example, a “user” module library will certainly expose a get() method, a create() method… In this state, you can’t expect any of the underlying microservices to be ready. In particular, the MongoDB datastore, and pubsub systems, will not be ready at this point deploy The second step is deploy, which means that you should call here all the registration points that your module will use. This includes: the Express applications you add to the platform the LESS files the JavaScript client files and Angular Modules the pub sub events you register and subscribe to start In this last step, your module starts actually doing its stuff. For example, if your module should publish a message in the message queue, or if it should send an email on startup, that should be done in that step. Usually, that step is empty."
					}

					
				
			
		
			
				
					,
					

					"modules-howto-install": {
						"id": "modules-howto-install",
						"title": "Install",
						"category": "",
						"url": " /modules/howto/install/",
						"content": "Table of contents Overview Manual installation From source From npm registry Configure Overview As described in the previous sections, OpenPaaS modules can be developed independently from the OpenPaaS platform. Once done, they have to be installed in the platform. While waiting for a runtime deployment, you will have to do some manual operations to add modules in the platform as listed below. Note: We assume that you already have a valid Node.JS version and NPM installed on your host Manual installation Modules can not be hot deployed in the OpenPaaS platform. Once installed following the instructions below, you will have to restart the platform (or start it if it was not started…). From source Get the sources from your SCM client, or download them from the repository manager and put them in the modules directory in the OpenPaaS one. For example, if your module is my.awesome.module, it should go in modules my.awesome.module (note that if you put the module source somewhere else, you can use symbolic links). In the module folder (modules my.awesome.module ), install the dependencies. A simple npm install should be enough. If not, check the module README.md to be sure. From npm registry If the module you want to use is available in the NPM registry, you can follow the following instructions. Change working directory to the OpenPaaS one Install the module from npm npm install my.awesome.module Configure In all the cases, a manual installation is not enough. You have to configure OpenPaaS to take the module into account by enabling it. This is achieved by modifying the config default.json by adding the module in the modules array: \"modules\": [ \"linagora.esn.account\", \"linagora.esn.calendar\", \"linagora.esn.contact\", \"...\", \"my.awesome.module\" ]"
					}

					
				
			
		
			
				
					,
					

					"modules-howto-quickstart": {
						"id": "modules-howto-quickstart",
						"title": "Quickstart",
						"category": "",
						"url": " /modules/howto/quickstart/",
						"content": "Table of contents Overview Let’s code Overview The OpenPaaS modules are the most powerfull way to add features into the OpenPaaS Enterprise Social Network. With modules, you can: add pages, or widgets, into the ESN web interface add REST endpoints, that thid party applications will be able to query expose objects and functions to other modules Let’s code In the modules folder of your OpenPaaS ESN installation, create a new folder com.example.module. Inside this folder, create a new file index.js, containing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const express = require('express'); const AwesomeModule = require('awesome-module'); const Dependency = AwesomeModule.AwesomeModuleDependency; const esnModule = new AwesomeModule('com.example.module', { dependencies: [ new Dependency(Dependency.TYPE_NAME, 'linagora.esn.core.webserver.wrapper', 'webserver-wrapper') ], states: { deploy: function(dependencies, callback) { const webserver = dependencies('webserver-wrapper'); const router = express.Router(); router.get(' ', (req,res) =&gt; { res.status(200).json({ok: true}); }); webserver.addApp('example', router); callback(); } } }); module.exports = esnModule; Now, open the configuration file config default.dev.json, and add the new modules at the end of your modules list: 1 2 3 4 5 6 7 { ... \"modules\": [ ..., \"com.example.module\" ] } Restart your ESN server, using the grunt dev command. You can now query your new endpoint : $ curl http: localhost:8080 example {\"ok\": true} Let’s now dig deeper in the OpenPaaS modules features."
					}

					
				
			
		
			
				
					,
					

					"modules-james-index": {
						"id": "modules-james-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/james/index/",
						"content": "Table of contents Overview Overview OpenPaaS module for communicate with James server"
					}

					
				
			
		
			
				
					,
					

					"modules-james-rest-api": {
						"id": "modules-james-rest-api",
						"title": "REST API",
						"category": "",
						"url": " /modules/james/rest-api/",
						"content": "Loading API documentation ..."
					}

					
				
			
		
			
				
					,
					

					"modules-jobqueue-index": {
						"id": "modules-jobqueue-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/jobqueue/index/",
						"content": "Table of contents Overview How it works? Register a worker Calling a worker to do his job Job object Overview In OpenPaaS ESN system, there are scenarios or tasks which consume a lot of system resources such as CPU time, memory, network bandwidth or IO. For example: reindex elasticsearch indices, import contacts and events from files or social accounts, send alarm emails to calendar event attendees, etc. Processing such tasks in NodeJS becomes even more challenging due to its single threaded and if you try to run them in parallel, system might become laggy or even crash. Solution to handle such tasks is to build a queue of tasks and process each task one by one so that each task is given good enough system resources. linagora.esn.jobqueue is a OpenPaaS ESN core module which base on Kue.This module provides APIs to create and manage queue job in OpenPaaS ESN. How it works? We need to register a worker by the worker name and its handler when starting OpenPaaS system If we want to execute a job, we need add the job to queue. To do that, we need to submit job with two params: Worker name: job queue gets the corresponding handler from registered workers by name Job data: after having handler, job queue then add a new job to queue with the handler and job data Register a worker The worker object to register is defined as: const jobName = 'contact-import'; dependencies('jobqueue').lib.addWorker({ name: jobName, handler: { handle getTitle } }) function handle(job) { const { user, account } = job.data; must return a promise return importContact(user, account); } function getTitle(jobData) { return `Import ${jobData.type} contacts for user ${jobData.user._id}`; } Calling a worker to do his job Once registered, you can call worker job by his name and data: const jobData = { user, account }; dependencies('jobqueue').lib.submitJob(jobName, jobData); Note that the jobData must be as lightweight as possible since it is stored in Redis Job object To get job object by his id: dependencies('jobqueue').lib.getJobById(jobId);"
					}

					
				
			
		
			
				
					,
					

					"modules-smartsla-index": {
						"id": "modules-smartsla-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/smartsla/index/",
						"content": "Table of contents Overview Installation 1. install the backend component 2. install the frontend app configuration: 1. frontend 2. backend Overview SmartSLA adds the ability for clients to create support tickets issues concerning supported software under a scope of a contract and interact with experts and admins. it consists of: frontend app built using VueJS. OpenPaaS component as backend, built using nodeJS. Installation here are the steps required to install the SmartSLA after you have installed OpenPaas 1. install the backend component $ESN_PATH is your openpaas installation path $SMARTSLA_PATH is your SmartSLA installation path clone and install the project git clone https: ci.linagora.com linagora lgs smartsla smartsla-backend.git cd smartsla-backend npm i export SMARTSLA_PATH=$(pwd) ```bash - link the module to openpaas ```bash cd $ESN_PATH modules ln -s $SMARTSLA_PATH smartsla-backend add it to the modules list: edit your $ESN_PATH config default.json and add smartsla-backend to the modules list ... \"modules\": [ ..., smartsla-backend ], ... for development check the component docs 2. install the frontend app clone and install the project: git clone https: ci.linagora.com linagora lgs smartsla smartsla-frontend.git cd smartsla-frontend npm i run the development server using npm run server now the application is up and running on localhost:8081 ( if esn is already running ) to build the frontend for production just run npm run build and host the contents of the dist folder to in your web server ( exemple nginx ) configuration: 1. frontend change the environment variables in public end openpaas.js to match your OpenPaaS instance: VUE_APP_OPENPAAS_URL is your openpaas instance url where the SmartSLA backend component is installed. SSP_URL is your SSP url to be used to reset user passwords. LIMESURVEY_URL is your limesurvey instance url. SUPPORT_ACCOUNT customize your SmartSLA information. 2. backend Set the limesurvey API in the configuration: http: limesurvey.smartsla.local is our limesurvey instance url export $ESN_URL=\"http: localhost:8080 \" export $ESN_ADMIN=\"admin@open-paas.org\" export $ESN_PASS=\"secret\" curl -X PUT -H 'Accept: application json' -H 'Content-Type: application json' $ESN_URL -u \"$ESN_ADMIN:$ESN_PASS\" -d '[ { \"name\": \"smartsla-backend\", \"configurations\": [ { \"name\": \"limesurvey\", \"value\": { \"surveyId\": 491487, \"apiUrl\": \"http: limesurvey.smartsla.local index.php admin remotecontrol \", \"username\": \"admin\", \"password\": \"password\" } } ] } ]'"
					}

					
				
			
		
			
				
					,
					

					"modules-unifiedinbox-identity": {
						"id": "modules-unifiedinbox-identity",
						"title": "Identity",
						"category": "",
						"url": " /modules/unifiedinbox/identity/",
						"content": "Table of contents Overview Identity structure Identity types Authorization Manage identities Management actions Overview To send outgoing email from OpenPaaS, you will need to set up at least one email identity. Email identities allow you to choose which address you want to use to send an email. You can set up as many identities as you need once domain administrator allows. Identity structure An identity contains: Required attributes: Description: To describe for an identity Name: The name of an identity Email address: The email to fill the From field when sending an email Optional attributes: Reply to address: Once defined, this email will be filled the To field instead of email address when the recipients reply to sender Mobile signature: The identity signature that is displayed when composing an email on desktop screen Desktop signature: The identity signature that is displayed when composing an email on mobile screen The valid values for Email adress and Reply to address of a specific user are: The user primary email The user email aliases The domain aliases if domain administrators allow by the following steps: Go to Administration module Then Modules page. Expand Unifiedinbox configuration form In the Identities part. Turn on Allow users to choose identity emails from domain aliases Identity types There are two types of identity: Default: The default identity of a user will be fill the From field as default when the user opens an email composer. A user only has one default identity. Additional: A user can have multiple additional identities that he can choose to fill the From field when composing an email Authorization Domain administrators are able to manage identities of their domain members. Domain members can see their identities. To manage their identites, they need the authorization from their domain administrators. A domain administrator can allow his domain members to manage their identities by the following steps: Go to Administration module Then Modules page. Expand Unifiedinbox configuration form In the Identities part. Turn on Allow users to manage their identities Manage identities Identities management interface of a specific user is available in a tab in user profile page Management actions There are 3 management actions: add, edit and remove. Users can set the default identity when adding a new identity or updating an existing identity Users can remove additional identities but cannot remove the default identity"
					}

					
				
			
		
			
				
					,
					

					"modules-unifiedinbox-index": {
						"id": "modules-unifiedinbox-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/unifiedinbox/index/",
						"content": "Table of contents Overview Install Overview The unified inbox module brings powerful and realtime emails support into the OpenPaaS platform. It is composed of several components: A frontend component, built using Angularjs. Backend components: A mail server Apache James Project A specific backend, built using Node.js Install Unified inbox is an OpenPaaS awesome module, you can install it by following the installation instructions."
					}

					
				
			
		
			
				
					,
					

					"modules-unifiedinbox-rest-api": {
						"id": "modules-unifiedinbox-rest-api",
						"title": "REST API",
						"category": "",
						"url": " /modules/unifiedinbox/rest-api/",
						"content": "Loading API documentation ..."
					}

					
				
			
		
			
				
					,
					

					"modules-videoconference-index": {
						"id": "modules-videoconference-index",
						"title": "Overview",
						"category": "",
						"url": " /modules/videoconference/index/",
						"content": "Table of contents Overview Installation 1. Install Jitsi 2. Install the required modules 3. Install the videoconference application Configure Overview The videoconference module brings videoconference support into the OpenPaaS platform. It is composed of several components: A frontend application. Built using Vue. 2 OpenPaaS core components. Built using angularjs and nodeJS. A ‘backend’ component: Jitsi Installation This guide provides you all the steps required to intall the videoconference application. 1. Install Jitsi We use a modified version of the Jitsi docker-compose project to run jitsi locally: Clone https: ci.linagora.com linagora lgs openpaas docker-jitsi-meet Switch to openpaas-dev branch Start jitsi: docker-compose up -d Jitsi is now up and running, you can join conference on http: localhost:8000 2. Install the required modules The videoconference application comes with 2 core modules: linagora.esn.videoconference provides core videoconference integration within OpenPaaS linagora.esn.videoconference.calendar provides calendar module integration As any other modules, clone them from git and use npm link to install them in OpenPaaS: git clone https: ci.linagora.com linagora lgs openpaas linagora.esn.videoconference.git git clone https: ci.linagora.com linagora lgs openpaas linagora.esn.videoconference.calendar.git cd linagora.esn.videoconference npm install npm link cd .. cd linagora.esn.videoconference.calendar npm install npm link cd $ESN_PATH # your ESN folder npm link linagora.esn.videoconference npm link linagora.esn.videoconference.calendar Finally, add linagora.esn.videoconference and linagora.esn.videoconference.calendar in the modules array of $ESN_PATH config default.json. 3. Install the videoconference application Follow the instructions from https: ci.linagora.com linagora lgs openpaas openpaas-videoconference-app Configure In order to work, the ESN must be configured with several URLs: the Jitsi instance URL the Videoconference Web application. As an administrator, log in into OpenPaaS, go to the administration modules videoconference, then fill URLs:"
					}

					
				
			
		
			
				
					,
					

					"modules-videoconference-screensharing": {
						"id": "modules-videoconference-screensharing",
						"title": "Screensharing",
						"category": "",
						"url": " /modules/videoconference/screensharing/",
						"content": "Table of contents Browser Server configuration Browser Screensharing is supported natively in Firefox while it needs a browser extension on Chrome. The Chrome extension sources are available at https: ci.linagora.com linagora lgs openpaas jidesha (Fork of https: github.com jitsi jidesha). The extension has to be configured to allow Chrome to access to Jitsi instances defined in its manifest file. For example, if the Jitsi instance is running on jitsi.open-paas.org, then the manifest.json file has to be updated accordingly: \"matches\": [ \"*: jitsi.open-paas.org *\" ] To package the extension and distribute it, follow the instruction on the repository README. Server configuration The Jitsi server needs to be configured to allow screensharing as described https: ci.linagora.com linagora lgs openpaas jidesha blob master README.md#enter-your-extensions-hash-id-into-your-jitsi-meet-installation. On the Docker based jitsi deployment, the extension id has to be defined in the this config.js file."
					}

					
				
			
		
			
				
					,
					

					"testing-midway-backend-test-index": {
						"id": "testing-midway-backend-test-index",
						"title": "Midway Backend Test",
						"category": "",
						"url": " /testing/midway-backend-test/index/",
						"content": "Table of contents Table of contents I. What is it II. Why do we need midway backend test III. How to work with midway backend test How to run tests Run all tests 1. For core ESN 2. For awesome modules inside of core ESN project 3. For external awesome modules (code is not included in the core ESN project) Run a single test How to write a new test Notes 1. Out of heap memory issue 2. How module midway tests load MongoDB configuration I. What is it Midway backend test is a type of test automation that we are using in our OpenPaaS development. Other test automation types are: Unit frontend test Unit backend test Unit storage test Midway backend test is created by the developer that worked with a specific feature or API. He needs to make sure that the midway backend test covers as many cases of his API as possible. It helps reduce QA testing time and gives the developer quick feedback about his code. We should prioritize write midway backend tests for our APIs. II. Why do we need midway backend test To make sure that our APIs are working properly with external services such as MongoDB, Redis, RabbitMQ, and ElasticSearch. This helps us to be confident that nothing breaks after refactoring our code and it integrates tightly with our CI CD platform Gitlab, which again, helps us to deploy products faster and safer. III. How to work with midway backend test How to run tests OpenPaaS uses Mocha, Chai, and Supertest behind the scenes to run execute perform the midway backend tests. Run all tests You can check the detail of each command in file Gruntfile.js located in the root folder of project core ESN 1. For core ESN You need to run this command: grunt docker-test-midway-backend This command will do 3 things: Set up environment and necessary service containers (MongoDB, Redis, RabbitMQ, and ElasticSearch) which is needed when running the tests. Run the actual midway backend tests. Kill all service containers and clean the environment after finishing tests. 2. For awesome modules inside of core ESN project You need to run this command: grunt docker-test-modules-midway Similar to the test in core ESN, this command will do 3 things: Set up environment and necessary service containers (MongoDB, Redis, RabbitMQ, and ElasticSearch) which is needed when running the tests of awesome modules. Run the actual module midway backend tests. Kill all service containers and clean the environment after finishing tests. 3. For external awesome modules (code is not included in the core ESN project) In external awesome modules, there is no Grunt task for setting up the environment or creating service containers. So you need to start these services (MongoDB, Redis, RabbitMQ, and ElasticSearch) by yourself before running the module midway backend tests. You can run these 4 commands manually: docker run -d --name esn-test-mongo -p 27017:27017 mongo:3.4.13 docker run -d --name esn-test-redis -p 6379:6379 redis:latest docker run -d --name esn-test-rabbit -p 5672:5672 rabbitmq:3.6.5-management docker run -d --name esn-elas -p 9200:9200 -e \"discovery.type=single-node\" docker.elastic.co elasticsearch elasticsearch:6.3.2 Or you can create a shell file, for example: setup-test-services.sh: #! bin sh docker run -d --name esn-test-mongo -p 27017:27017 mongo:3.4.13 docker run -d --name esn-test-redis -p 6379:6379 redis:latest docker run -d --name esn-test-rabbit -p 5672:5672 rabbitmq:3.6.5-management docker run -d --name esn-elas -p 9200:9200 -e \"discovery.type=single-node\" docker.elastic.co elasticsearch elasticsearch:6.3.2 And run: chmod +x setup-test-services.sh . setup-test-services.sh Using this way, you don’t have to remember each command on the next time you want to start test services. After that, you need to run this command: grunt test-midway-backend This command will do only 1 thing: Run the actual midway backend tests of this external module. Run a single test Running a single test is very similar to running all tests above, you just need to find the test that you want to run, add .only and run the corresponding command. For example: Update the test that you want to run like this: Then run: grunt docker-test-midway-backend You can find more information about .only here: https: mochajs.org #exclusive-tests How to write a new test A complete guide to write a new midway backend test would be too long for this document, so we will write another detailed document to do it. In this document, we will just have a glimpse over what needs to be done: Check this file first test midway-backend all.js. This file configures everything required to run the tests. Then you need to write your test cases in the corresponding folders. For example api or middleware. Normal test cases usually start with a describe block, and inside of this block, we have some it blocks. For example, describe('GET api activitystreams :uuid', function() { it('should send back 401 when not logged in', function(done) { helpers.api.requireLogin(app, 'get', ' api activitystreams ' + activitystreamId, done); }); it('should send back 404 when the activity stream does not exist', function(done) { const incorrectUUID = uuidV4(); helpers.api.loginAsUser(app, email, password, function(err, loggedInAsUser) { expect(err).to.not.exist; loggedInAsUser(request(app).get(' api activitystreams ' + incorrectUUID)) .expect(404, done); }); }); it('should send back 400 when limit parameter is incorrect', function(done) { helpers.api.loginAsUser(app, email, password, function(err, loggedInAsUser) { expect(err).to.not.exist; loggedInAsUser(request(app).get(' api activitystreams ' + activitystreamId + '?limit=-12')) .expect(400, done); }); }); ... }); You can find more information on Mocha website: https: mochajs.org #getting-started or check some test cases inside of test midway-backend folder of core ESN project or any other external awesome modules. Notes This section contains some of the useful notes that newcomers might have when they start working with ESN. We will update this section regularly. 1. Out of heap memory issue Sometimes when running all the midway backend tests of core ESN project, you might see that your computer is not responding and you have to restart it. The reason is: Mocha loaded all the tests into your computer’s memory and run all at once, which will eat all RAM of your computer. To prevent Mocha from doing this, you need to add --chunk=1 after every command that runs a large number of tests. For example: grunt docker-test-midway-backend --chunk=1 Note: Remember, for “Run a single test” case above, do NOT add --chunk=1 at the end of the command. Doing so will cause it to run all the tests. 2. How module midway tests load MongoDB configuration In an external awesome module (for example, linagora.esn.chat), if you check the file test midway-backend all.js, you are going to see this line: process.env.NODE_CONFIG = 'test config'; Now come back to the core ESN project, check the file backend core config index.js, you will see something like this: 'use strict'; We can define the config path from the NODE_CONFIG This may be useful for tests Note that it loks that konphyg does not handle undefined and null so we have to be it here this way var config = process.env.NODE_CONFIG; if (!config || config === undefined || config === 'undefined' || config === null || config === 'null') { config = __dirname + ' .. .. .. config'; } exports = module.exports = require('konphyg')(config); This environment variable process.env.NODE_CONFIG is what decides where the config will be loaded for the midway backend tests of an external awesome module. And in this case, it loads the config inside of the folder test config of module linagora.esn.chat Now, let’s check this file backend core db mongo index.js, you will see this function: function getConnectionStringAndOptions() { let dbConfig; try { dbConfig = config('db'); } catch (e) { return false; } if (!dbConfig) { return false; } Note: erasing dbConfig.connectionString here is a dirty hack to avoid presenting the setup wizard to the user. See https: ci.linagora.com linagora lgs openpaas esn issues 2412 dbConfig.connectionString = dbConfig.connectionString || getConnectionStringFromEnvOrDefaults(); const connectionOptions = dbConfig.connectionOptions || getDefaultOptions(); return { url: dbConfig.connectionString, options: connectionOptions }; } As you can see, this line dbConfig = config('db'); is what will load the config from db.json inside test config folder, and then send it to mongoose.connect() function."
					}

					
				
			
		
	};
</script>
<script src="/js/modules/lunr.min.js"></script>
<script src="/js/search.js"></script>

			</article>
		</section>

		<script>
			var content = document.getElementsByClassName('content')[0];

			if (content) {
				var viewer = new Viewer(content, {
					movable: false,
					rotatable: false
				});

				var images = content.getElementsByTagName('img');
				for (var i = 0; i < images.length; i++) {
					images[i].style.cursor = 'pointer';
				}
			}

			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
